*****************
Typer -> Proper
*****************
- Conversion de tipos Typer a tipos Proper
- Calculo de interseccion de tipos cuando una variable se utiliza varias veces en una clausula f(X,A,X)

- Los tipos son los de las spec definidas por el usuario % ACTUALMENTE
- Hacer interseccion entre tipos Typer y specs % PENDING

- Calcular tipo por clausulas utilizando typer Tama % PENDING

*************************************************
	Cuter & Random
*************************************************
Phase 1: Cuter

+ Se generan mas tests con Proper hasta: 
1.- Alcanzar la cobertura deseada %NO
2.- Alcanzar el numero maximo de tests esperados %NO
3.- Alcanzar el timeout 

***** TODO *****
+ Hacer el espejo. Dividimos el tiempo por 2 y aplicamos la mitad de tiempo a generar inputs en program1 y la otra mitad a generat inputs en program2 (sobretodo por el tema de que CutEr hara que se evaluen mas caminos).

+ Cuando el POI es una variable en un patron, al que llega con un valor previo, se enviara el valor que intentará hacer matching, no el que tenia.
+ En la LC el solucionar el problema del generador del ejemplo:
	 [undef || {X,PI,{X,2,Y}} <- L, Y > 1] 
	 				FV = {X,2,Y} 

	 			{X,PI,FV} <- L, begin 
	 								{X,2,Y} = FV,
	 								Y > 1
	 							end
+ La solucion de la lc es un generador con la parte de la derecha del POI en lugar de un filtro. 
+ Tenemos que asegurarnos de pasar por todas las clausulas y evitar que se genenren valores siempre para la misma clausula
en el mutating test

+ Ampliaciones:
	- Definir una lista de puntos de interes, esto lleva a instrumentar todos los puntos de interes simultaneamente, y obtener los resultados de todos en una sola ejecución. 
+ Probar funciones de aridad 0

+ Al seleccionar patron de clause, la guarda debe ponerse a true % DONE
+ Definir una lista de funciones como funcion de entrada % DONE
+ No definir funcion de entrada coger exports
+ En la LC el generador debe ( {A,B,C,Pi,B,D,D} <-  L) =>  ({A,B,C,Pi,FV1,D,FV2} <- L) URGENTE

+ Dividir las guardas para tener en cuenta cortocircuitados y instrumentarlo a base de cases de cases 

+ Probar si funciona en concurrencia con ejemplos deterministas de concurrencia (Para el paper)

+ Parametro fun:
¿Proper genera funs? 
¿Cuter como lleva lo de las funs como parametros de entrada?

+ Reprintear el AST al principio para que la organización del mismo sea adecuada al medir la cobertura con COVER. % PENDING
+ Obtener las trazas de 2 programas en paralelo y matar la ejecución al hallar una divergencia % PENDING

+ typer_mod.erl es una fuente de error, por las distintas versiones de typer. Hay que notificar el error en la herramienta
con algun mensaje y dar una direccion github para descargar la version alternativa

***** DONE ******

+ Arreglar replace after position, entrar en profundidad en cada elemento de la izq de pos y realizar los cambios pertinentes
teniendo en cuenta lo que se sustituye a la antes al profundizar y sustituyendo cada variable con el mismo nombre por la misma
FreeVar URGENTE En principio: % DONE

+ Las trazas no vacias obtenidas por cuter se deben utilizar para generar nuevos inputs, no desecharlas % DONE
+ Detectar de que clausula es el input generado por cuter %DONE
+ Cambiar lo del offset por linea, variable y ocurrencia. Utilizar el AST para cambiar ese nodo por slicing_criterion y usar 
el nuevo AST para instrumentar directamente % DONE*
+ No sustituir por slicing_criterion sino localizar directamente el SC en la funcion get_path con la informacion line,var,oc. %DONE

+ Tests fijando parametros
Utilizar dicts en un servidor cuyo estado son 2 diccionarios (inputs y trazas). % DONE (4 DICTS)
Cuando se calcule una mutacion con traza nueva se enviara un mensaje a si mismo con dicha mutacion y el atomo pending para procesarla. Si llega un mensaje de stop se abortara el procesamiento de los pendings restantes recibidos despues. % DONE (ALGO DIFERENTE)

+ Para integers, cuando proper no genera un test nuevo despues de 50 intentos se incrementa 
el rango de valores validos (al no poner rango explicito proper genera enteros entre -20 y 20 aproximadamente) % DONE
+ Definir la aridad en secer y diferenciar entre funciones con el mismo nombre y distinta aridad %DONE

+ Buscar un programa o diseñar uno sencillo donde tengamos 3 versiones (Vital para el paper) % DONE
1.- Programa original
2.- Version refactorizada con errores
3.- Version final sin errores