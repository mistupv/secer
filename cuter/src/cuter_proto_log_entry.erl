%% -*- coding: utf-8 -*-
%% Automatically generated, do not edit
%% Generated by gpb_compile version 3.26.4
-module(cuter_proto_log_entry).

-export([encode_msg/1, encode_msg/2]).
-export([decode_msg/2, decode_msg/3]).
-export([merge_msgs/2, merge_msgs/3]).
-export([verify_msg/1, verify_msg/2]).
-export([get_msg_defs/0]).
-export([get_msg_names/0]).
-export([get_enum_names/0]).
-export([find_msg_def/1, fetch_msg_def/1]).
-export([find_enum_def/1, fetch_enum_def/1]).
-export([enum_symbol_by_value/2, enum_value_by_symbol/2]).
-export(['enum_symbol_by_value_LogEntry.Type'/1, 'enum_value_by_symbol_LogEntry.Type'/1]).
-export(['enum_symbol_by_value_ErlangTerm.Type'/1, 'enum_value_by_symbol_ErlangTerm.Type'/1]).
-export(['enum_symbol_by_value_Spec.ErlType'/1, 'enum_value_by_symbol_Spec.ErlType'/1]).
-export([get_service_names/0]).
-export([get_service_def/1]).
-export([get_rpc_names/1]).
-export([find_rpc_def/2, fetch_rpc_def/2]).
-export([get_package_name/0]).
-export([gpb_version_as_string/0, gpb_version_as_list/0]).

-include("cuter_proto_log_entry.hrl").
-include("gpb.hrl").


-record('map<string,ErlangTerm>',{key, value}).

-spec encode_msg(_) -> binary().
encode_msg(Msg) -> encode_msg(Msg, []).


-spec encode_msg(_, list()) -> binary().
encode_msg(Msg, Opts) ->
    case proplists:get_bool(verify, Opts) of
      true -> verify_msg(Msg, Opts);
      false -> ok
    end,
    TrUserData = proplists:get_value(user_data, Opts),
    case Msg of
      #'LogEntry'{} -> e_msg_LogEntry(Msg, TrUserData);
      #'ErlangTerm.MapEntry'{} ->
	  'e_msg_ErlangTerm.MapEntry'(Msg, TrUserData);
      #'ErlangTerm.FunEntry'{} ->
	  'e_msg_ErlangTerm.FunEntry'(Msg, TrUserData);
      #'ErlangTerm'{} -> e_msg_ErlangTerm(Msg, TrUserData);
      #'Spec.TypeDef'{} ->
	  'e_msg_Spec.TypeDef'(Msg, TrUserData);
      #'Spec.RangeBounds'{} ->
	  'e_msg_Spec.RangeBounds'(Msg, TrUserData);
      #'Spec.SegmentSize'{} ->
	  'e_msg_Spec.SegmentSize'(Msg, TrUserData);
      #'Spec.FunSig'{} ->
	  'e_msg_Spec.FunSig'(Msg, TrUserData);
      #'Spec.FunDet'{} ->
	  'e_msg_Spec.FunDet'(Msg, TrUserData);
      #'Spec.Type'{} -> 'e_msg_Spec.Type'(Msg, TrUserData);
      #'Spec.TypeList'{} ->
	  'e_msg_Spec.TypeList'(Msg, TrUserData);
      #'Spec'{} -> e_msg_Spec(Msg, TrUserData)
    end.



e_msg_LogEntry(Msg, TrUserData) ->
    e_msg_LogEntry(Msg, <<>>, TrUserData).


e_msg_LogEntry(#'LogEntry'{type = F1, arguments = F2,
			   is_constraint = F3, tag = F4, spec = F5},
	       Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  if TrF1 =:= 'OP_PARAMS' -> Bin;
		     true -> 'e_enum_LogEntry.Type'(TrF1, <<Bin/binary, 8>>)
		  end
		end
	 end,
    B2 = begin
	   TrF2 = id(F2, TrUserData),
	   if TrF2 == [] -> B1;
	      true -> e_field_LogEntry_arguments(TrF2, B1, TrUserData)
	   end
	 end,
    B3 = if F3 == undefined -> B2;
	    true ->
		begin
		  TrF3 = id(F3, TrUserData),
		  if TrF3 =:= false -> B2;
		     true -> e_type_bool(TrF3, <<B2/binary, 24>>)
		  end
		end
	 end,
    B4 = if F4 == undefined -> B3;
	    true ->
		begin
		  TrF4 = id(F4, TrUserData),
		  if TrF4 =:= 0 -> B3;
		     true -> e_varint(TrF4, <<B3/binary, 32>>)
		  end
		end
	 end,
    if F5 == undefined -> B4;
       true ->
	   begin
	     TrF5 = id(F5, TrUserData),
	     if TrF5 =:= undefined -> B4;
		true ->
		    e_mfield_LogEntry_spec(TrF5, <<B4/binary, 42>>,
					   TrUserData)
	     end
	   end
    end.

'e_msg_ErlangTerm.MapEntry'(Msg, TrUserData) ->
    'e_msg_ErlangTerm.MapEntry'(Msg, <<>>, TrUserData).


'e_msg_ErlangTerm.MapEntry'(#'ErlangTerm.MapEntry'{key =
						       F1,
						   value = F2},
			    Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  if TrF1 =:= undefined -> Bin;
		     true ->
			 'e_mfield_ErlangTerm.MapEntry_key'(TrF1,
							    <<Bin/binary, 10>>,
							    TrUserData)
		  end
		end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     if TrF2 =:= undefined -> B1;
		true ->
		    'e_mfield_ErlangTerm.MapEntry_value'(TrF2,
							 <<B1/binary, 18>>,
							 TrUserData)
	     end
	   end
    end.

'e_msg_ErlangTerm.FunEntry'(Msg, TrUserData) ->
    'e_msg_ErlangTerm.FunEntry'(Msg, <<>>, TrUserData).


'e_msg_ErlangTerm.FunEntry'(#'ErlangTerm.FunEntry'{arguments
						       = F1,
						   value = F2},
			    Bin, TrUserData) ->
    B1 = begin
	   TrF1 = id(F1, TrUserData),
	   if TrF1 == [] -> Bin;
	      true ->
		  'e_field_ErlangTerm.FunEntry_arguments'(TrF1, Bin,
							  TrUserData)
	   end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     if TrF2 =:= undefined -> B1;
		true ->
		    'e_mfield_ErlangTerm.FunEntry_value'(TrF2,
							 <<B1/binary, 18>>,
							 TrUserData)
	     end
	   end
    end.

e_msg_ErlangTerm(Msg, TrUserData) ->
    e_msg_ErlangTerm(Msg, <<>>, TrUserData).


e_msg_ErlangTerm(#'ErlangTerm'{type = F1, value = F2,
			       subterms = F3, shared = F4,
			       improper_list_nil = F5, atom_chars = F6,
			       bits = F7, map_entries = F8, points = F9,
			       otherwise = F10, arity = F11},
		 Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  if TrF1 =:= 'INTEGER' -> Bin;
		     true ->
			 'e_enum_ErlangTerm.Type'(TrF1, <<Bin/binary, 8>>)
		  end
		end
	 end,
    B2 = if F2 == undefined -> B1;
	    true ->
		begin
		  TrF2 = id(F2, TrUserData),
		  case iolist_size(TrF2) of
		    0 -> B1;
		    _ -> e_type_string(TrF2, <<B1/binary, 18>>)
		  end
		end
	 end,
    B3 = begin
	   TrF3 = id(F3, TrUserData),
	   if TrF3 == [] -> B2;
	      true ->
		  e_field_ErlangTerm_subterms(TrF3, B2, TrUserData)
	   end
	 end,
    B4 = begin
	   TrF4 = id(F4, TrUserData),
	   if TrF4 == [] -> B3;
	      true -> e_field_ErlangTerm_shared(TrF4, B3, TrUserData)
	   end
	 end,
    B5 = if F5 == undefined -> B4;
	    true ->
		begin
		  TrF5 = id(F5, TrUserData),
		  if TrF5 =:= undefined -> B4;
		     true ->
			 e_mfield_ErlangTerm_improper_list_nil(TrF5,
							       <<B4/binary,
								 42>>,
							       TrUserData)
		  end
		end
	 end,
    B6 = begin
	   TrF6 = id(F6, TrUserData),
	   if TrF6 == [] -> B5;
	      true ->
		  e_field_ErlangTerm_atom_chars(TrF6, B5, TrUserData)
	   end
	 end,
    B7 = begin
	   TrF7 = id(F7, TrUserData),
	   if TrF7 == [] -> B6;
	      true -> e_field_ErlangTerm_bits(TrF7, B6, TrUserData)
	   end
	 end,
    B8 = begin
	   TrF8 = id(F8, TrUserData),
	   if TrF8 == [] -> B7;
	      true ->
		  e_field_ErlangTerm_map_entries(TrF8, B7, TrUserData)
	   end
	 end,
    B9 = begin
	   TrF9 = id(F9, TrUserData),
	   if TrF9 == [] -> B8;
	      true -> e_field_ErlangTerm_points(TrF9, B8, TrUserData)
	   end
	 end,
    B10 = if F10 == undefined -> B9;
	     true ->
		 begin
		   TrF10 = id(F10, TrUserData),
		   if TrF10 =:= undefined -> B9;
		      true ->
			  e_mfield_ErlangTerm_otherwise(TrF10,
							<<B9/binary, 82>>,
							TrUserData)
		   end
		 end
	  end,
    if F11 == undefined -> B10;
       true ->
	   begin
	     TrF11 = id(F11, TrUserData),
	     if TrF11 =:= 0 -> B10;
		true -> e_type_int32(TrF11, <<B10/binary, 88>>)
	     end
	   end
    end.

'e_msg_Spec.TypeDef'(Msg, TrUserData) ->
    'e_msg_Spec.TypeDef'(Msg, <<>>, TrUserData).


'e_msg_Spec.TypeDef'(#'Spec.TypeDef'{name = F1,
				     definition = F2},
		     Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case iolist_size(TrF1) of
		    0 -> Bin;
		    _ -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     if TrF2 =:= undefined -> B1;
		true ->
		    'e_mfield_Spec.TypeDef_definition'(TrF2,
						       <<B1/binary, 18>>,
						       TrUserData)
	     end
	   end
    end.

'e_msg_Spec.RangeBounds'(Msg, TrUserData) ->
    'e_msg_Spec.RangeBounds'(Msg, <<>>, TrUserData).


'e_msg_Spec.RangeBounds'(#'Spec.RangeBounds'{lower_bound
						 = F1,
					     upper_bound = F2},
			 Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case iolist_size(TrF1) of
		    0 -> Bin;
		    _ -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     case iolist_size(TrF2) of
	       0 -> B1;
	       _ -> e_type_string(TrF2, <<B1/binary, 18>>)
	     end
	   end
    end.

'e_msg_Spec.SegmentSize'(Msg, TrUserData) ->
    'e_msg_Spec.SegmentSize'(Msg, <<>>, TrUserData).


'e_msg_Spec.SegmentSize'(#'Spec.SegmentSize'{m = F1,
					     n = F2},
			 Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  case iolist_size(TrF1) of
		    0 -> Bin;
		    _ -> e_type_string(TrF1, <<Bin/binary, 10>>)
		  end
		end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     case iolist_size(TrF2) of
	       0 -> B1;
	       _ -> e_type_string(TrF2, <<B1/binary, 18>>)
	     end
	   end
    end.

'e_msg_Spec.FunSig'(Msg, TrUserData) ->
    'e_msg_Spec.FunSig'(Msg, <<>>, TrUserData).


'e_msg_Spec.FunSig'(#'Spec.FunSig'{signature = F1}, Bin,
		    TrUserData) ->
    case F1 of
      undefined -> Bin;
      {complete, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    'e_mfield_Spec.FunSig_complete'(TrOF1,
					    <<Bin/binary, 10>>, TrUserData)
	  end;
      {just_return, OF1} ->
	  begin
	    TrOF1 = id(OF1, TrUserData),
	    'e_mfield_Spec.FunSig_just_return'(TrOF1,
					       <<Bin/binary, 18>>, TrUserData)
	  end
    end.

'e_msg_Spec.FunDet'(Msg, TrUserData) ->
    'e_msg_Spec.FunDet'(Msg, <<>>, TrUserData).


'e_msg_Spec.FunDet'(#'Spec.FunDet'{parameters = F1,
				   return_value = F2},
		    Bin, TrUserData) ->
    B1 = begin
	   TrF1 = id(F1, TrUserData),
	   if TrF1 == [] -> Bin;
	      true ->
		  'e_field_Spec.FunDet_parameters'(TrF1, Bin, TrUserData)
	   end
	 end,
    if F2 == undefined -> B1;
       true ->
	   begin
	     TrF2 = id(F2, TrUserData),
	     if TrF2 =:= undefined -> B1;
		true ->
		    'e_mfield_Spec.FunDet_return_value'(TrF2,
							<<B1/binary, 18>>,
							TrUserData)
	     end
	   end
    end.

'e_msg_Spec.Type'(Msg, TrUserData) ->
    'e_msg_Spec.Type'(Msg, <<>>, TrUserData).


'e_msg_Spec.Type'(#'Spec.Type'{type = F1, arg = F2},
		  Bin, TrUserData) ->
    B1 = if F1 == undefined -> Bin;
	    true ->
		begin
		  TrF1 = id(F1, TrUserData),
		  if TrF1 =:= 'ANY' -> Bin;
		     true -> 'e_enum_Spec.ErlType'(TrF1, <<Bin/binary, 8>>)
		  end
		end
	 end,
    case F2 of
      undefined -> B1;
      {literal, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_literal'(TrOF2, <<B1/binary, 18>>,
					 TrUserData)
	  end;
      {range_bounds, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_range_bounds'(TrOF2,
					      <<B1/binary, 26>>, TrUserData)
	  end;
      {segment_size, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_segment_size'(TrOF2,
					      <<B1/binary, 34>>, TrUserData)
	  end;
      {inner_type, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_inner_type'(TrOF2,
					    <<B1/binary, 42>>, TrUserData)
	  end;
      {inner_types, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_inner_types'(TrOF2,
					     <<B1/binary, 50>>, TrUserData)
	  end;
      {'fun', OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    'e_mfield_Spec.Type_fun'(TrOF2, <<B1/binary, 58>>,
				     TrUserData)
	  end;
      {ntuple_size, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    e_varint(TrOF2, <<B1/binary, 64>>)
	  end;
      {type_name, OF2} ->
	  begin
	    TrOF2 = id(OF2, TrUserData),
	    e_type_string(TrOF2, <<B1/binary, 74>>)
	  end
    end.

'e_msg_Spec.TypeList'(Msg, TrUserData) ->
    'e_msg_Spec.TypeList'(Msg, <<>>, TrUserData).


'e_msg_Spec.TypeList'(#'Spec.TypeList'{types = F1}, Bin,
		      TrUserData) ->
    begin
      TrF1 = id(F1, TrUserData),
      if TrF1 == [] -> Bin;
	 true ->
	     'e_field_Spec.TypeList_types'(TrF1, Bin, TrUserData)
      end
    end.

e_msg_Spec(Msg, TrUserData) ->
    e_msg_Spec(Msg, <<>>, TrUserData).


e_msg_Spec(#'Spec'{clauses = F1, typedefs = F2}, Bin,
	   TrUserData) ->
    B1 = begin
	   TrF1 = id(F1, TrUserData),
	   if TrF1 == [] -> Bin;
	      true -> e_field_Spec_clauses(TrF1, Bin, TrUserData)
	   end
	 end,
    begin
      TrF2 = id(F2, TrUserData),
      if TrF2 == [] -> B1;
	 true -> e_field_Spec_typedefs(TrF2, B1, TrUserData)
      end
    end.

e_mfield_LogEntry_arguments(Msg, Bin, TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_LogEntry_arguments([Elem | Rest], Bin,
			   TrUserData) ->
    Bin2 = <<Bin/binary, 18>>,
    Bin3 = e_mfield_LogEntry_arguments(id(Elem, TrUserData),
				       Bin2, TrUserData),
    e_field_LogEntry_arguments(Rest, Bin3, TrUserData);
e_field_LogEntry_arguments([], Bin, _TrUserData) -> Bin.

e_mfield_LogEntry_spec(Msg, Bin, TrUserData) ->
    SubBin = e_msg_Spec(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_ErlangTerm.MapEntry_key'(Msg, Bin,
				   TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_ErlangTerm.MapEntry_value'(Msg, Bin,
				     TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_ErlangTerm.FunEntry_arguments'(Msg, Bin,
					 TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_field_ErlangTerm.FunEntry_arguments'([Elem | Rest],
					Bin, TrUserData) ->
    Bin2 = <<Bin/binary, 10>>,
    Bin3 = 'e_mfield_ErlangTerm.FunEntry_arguments'(id(Elem,
						       TrUserData),
						    Bin2, TrUserData),
    'e_field_ErlangTerm.FunEntry_arguments'(Rest, Bin3,
					    TrUserData);
'e_field_ErlangTerm.FunEntry_arguments'([], Bin,
					_TrUserData) ->
    Bin.

'e_mfield_ErlangTerm.FunEntry_value'(Msg, Bin,
				     TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_mfield_ErlangTerm_subterms(Msg, Bin, TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_ErlangTerm_subterms([Elem | Rest], Bin,
			    TrUserData) ->
    Bin2 = <<Bin/binary, 26>>,
    Bin3 = e_mfield_ErlangTerm_subterms(id(Elem,
					   TrUserData),
					Bin2, TrUserData),
    e_field_ErlangTerm_subterms(Rest, Bin3, TrUserData);
e_field_ErlangTerm_subterms([], Bin, _TrUserData) ->
    Bin.

e_mfield_ErlangTerm_shared(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_map<string,ErlangTerm>'(Msg, <<>>,
					    TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_ErlangTerm_shared([Elem | Rest], Bin,
			  TrUserData) ->
    Bin2 = <<Bin/binary, 34>>,
    Bin3 =
	e_mfield_ErlangTerm_shared('tr_encode_ErlangTerm.shared[x]'(Elem,
								    TrUserData),
				   Bin2, TrUserData),
    e_field_ErlangTerm_shared(Rest, Bin3, TrUserData);
e_field_ErlangTerm_shared([], Bin, _TrUserData) -> Bin.

e_mfield_ErlangTerm_improper_list_nil(Msg, Bin,
				      TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_ErlangTerm_atom_chars(Elems, Bin, TrUserData)
    when Elems =/= [] ->
    SubBin = e_pfield_ErlangTerm_atom_chars(Elems, <<>>,
					    TrUserData),
    Bin2 = <<Bin/binary, 50>>,
    Bin3 = e_varint(byte_size(SubBin), Bin2),
    <<Bin3/binary, SubBin/binary>>;
e_field_ErlangTerm_atom_chars([], Bin, _TrUserData) ->
    Bin.

e_pfield_ErlangTerm_atom_chars([Value | Rest], Bin,
			       TrUserData) ->
    Bin2 = e_type_int32(id(Value, TrUserData), Bin),
    e_pfield_ErlangTerm_atom_chars(Rest, Bin2, TrUserData);
e_pfield_ErlangTerm_atom_chars([], Bin, _TrUserData) ->
    Bin.

e_field_ErlangTerm_bits(Elems, Bin, TrUserData)
    when Elems =/= [] ->
    SubBin = e_pfield_ErlangTerm_bits(Elems, <<>>,
				      TrUserData),
    Bin2 = <<Bin/binary, 58>>,
    Bin3 = e_varint(byte_size(SubBin), Bin2),
    <<Bin3/binary, SubBin/binary>>;
e_field_ErlangTerm_bits([], Bin, _TrUserData) -> Bin.

e_pfield_ErlangTerm_bits([Value | Rest], Bin,
			 TrUserData) ->
    Bin2 = e_type_bool(id(Value, TrUserData), Bin),
    e_pfield_ErlangTerm_bits(Rest, Bin2, TrUserData);
e_pfield_ErlangTerm_bits([], Bin, _TrUserData) -> Bin.

e_mfield_ErlangTerm_map_entries(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_ErlangTerm.MapEntry'(Msg, <<>>,
					 TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_ErlangTerm_map_entries([Elem | Rest], Bin,
			       TrUserData) ->
    Bin2 = <<Bin/binary, 66>>,
    Bin3 = e_mfield_ErlangTerm_map_entries(id(Elem,
					      TrUserData),
					   Bin2, TrUserData),
    e_field_ErlangTerm_map_entries(Rest, Bin3, TrUserData);
e_field_ErlangTerm_map_entries([], Bin, _TrUserData) ->
    Bin.

e_mfield_ErlangTerm_points(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_ErlangTerm.FunEntry'(Msg, <<>>,
					 TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_ErlangTerm_points([Elem | Rest], Bin,
			  TrUserData) ->
    Bin2 = <<Bin/binary, 74>>,
    Bin3 = e_mfield_ErlangTerm_points(id(Elem, TrUserData),
				      Bin2, TrUserData),
    e_field_ErlangTerm_points(Rest, Bin3, TrUserData);
e_field_ErlangTerm_points([], Bin, _TrUserData) -> Bin.

e_mfield_ErlangTerm_otherwise(Msg, Bin, TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.TypeDef_definition'(Msg, Bin,
				   TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.FunSig_complete'(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.FunDet'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.FunSig_just_return'(Msg, Bin,
				   TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.FunDet_parameters'(Msg, Bin,
				  TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_field_Spec.FunDet_parameters'([Elem | Rest], Bin,
				 TrUserData) ->
    Bin2 = <<Bin/binary, 10>>,
    Bin3 = 'e_mfield_Spec.FunDet_parameters'(id(Elem,
						TrUserData),
					     Bin2, TrUserData),
    'e_field_Spec.FunDet_parameters'(Rest, Bin3,
				     TrUserData);
'e_field_Spec.FunDet_parameters'([], Bin,
				 _TrUserData) ->
    Bin.

'e_mfield_Spec.FunDet_return_value'(Msg, Bin,
				    TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_literal'(Msg, Bin, TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_range_bounds'(Msg, Bin,
				  TrUserData) ->
    SubBin = 'e_msg_Spec.RangeBounds'(Msg, <<>>,
				      TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_segment_size'(Msg, Bin,
				  TrUserData) ->
    SubBin = 'e_msg_Spec.SegmentSize'(Msg, <<>>,
				      TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_inner_type'(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_inner_types'(Msg, Bin,
				 TrUserData) ->
    SubBin = 'e_msg_Spec.TypeList'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.Type_fun'(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.FunSig'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_mfield_Spec.TypeList_types'(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.Type'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

'e_field_Spec.TypeList_types'([Elem | Rest], Bin,
			      TrUserData) ->
    Bin2 = <<Bin/binary, 10>>,
    Bin3 = 'e_mfield_Spec.TypeList_types'(id(Elem,
					     TrUserData),
					  Bin2, TrUserData),
    'e_field_Spec.TypeList_types'(Rest, Bin3, TrUserData);
'e_field_Spec.TypeList_types'([], Bin, _TrUserData) ->
    Bin.

e_mfield_Spec_clauses(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.FunSig'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_Spec_clauses([Elem | Rest], Bin, TrUserData) ->
    Bin2 = <<Bin/binary, 10>>,
    Bin3 = e_mfield_Spec_clauses(id(Elem, TrUserData), Bin2,
				 TrUserData),
    e_field_Spec_clauses(Rest, Bin3, TrUserData);
e_field_Spec_clauses([], Bin, _TrUserData) -> Bin.

e_mfield_Spec_typedefs(Msg, Bin, TrUserData) ->
    SubBin = 'e_msg_Spec.TypeDef'(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.

e_field_Spec_typedefs([Elem | Rest], Bin, TrUserData) ->
    Bin2 = <<Bin/binary, 18>>,
    Bin3 = e_mfield_Spec_typedefs(id(Elem, TrUserData),
				  Bin2, TrUserData),
    e_field_Spec_typedefs(Rest, Bin3, TrUserData);
e_field_Spec_typedefs([], Bin, _TrUserData) -> Bin.


'e_msg_map<string,ErlangTerm>'(#'map<string,ErlangTerm>'{key
							     = F1,
							 value = F2},
			       Bin, TrUserData) ->
    B1 = begin
	   TrF1 = id(F1, TrUserData),
	   e_type_string(TrF1, <<Bin/binary, 10>>)
	 end,
    begin
      TrF2 = id(F2, TrUserData),
      'e_mfield_map<string,ErlangTerm>_value'(TrF2,
					      <<B1/binary, 18>>, TrUserData)
    end.

'e_mfield_map<string,ErlangTerm>_value'(Msg, Bin,
					TrUserData) ->
    SubBin = e_msg_ErlangTerm(Msg, <<>>, TrUserData),
    Bin2 = e_varint(byte_size(SubBin), Bin),
    <<Bin2/binary, SubBin/binary>>.


'e_enum_LogEntry.Type'('OP_PARAMS', Bin) ->
    <<Bin/binary, 0>>;
'e_enum_LogEntry.Type'('OP_SPEC', Bin) ->
    <<Bin/binary, 1>>;
'e_enum_LogEntry.Type'('OP_LAMBDA', Bin) ->
    <<Bin/binary, 2>>;
'e_enum_LogEntry.Type'('OP_EVALUATED_CLOSURE', Bin) ->
    <<Bin/binary, 3>>;
'e_enum_LogEntry.Type'('OP_FRESH_LAMBDA_WITH_ARITY',
		       Bin) ->
    <<Bin/binary, 4>>;
'e_enum_LogEntry.Type'('OP_NOT_LAMBDA_WITH_ARITY',
		       Bin) ->
    <<Bin/binary, 5>>;
'e_enum_LogEntry.Type'('OP_GUARD_TRUE', Bin) ->
    <<Bin/binary, 6>>;
'e_enum_LogEntry.Type'('OP_GUARD_FALSE', Bin) ->
    <<Bin/binary, 7>>;
'e_enum_LogEntry.Type'('OP_MATCH_EQUAL_TRUE', Bin) ->
    <<Bin/binary, 8>>;
'e_enum_LogEntry.Type'('OP_MATCH_EQUAL_FALSE', Bin) ->
    <<Bin/binary, 9>>;
'e_enum_LogEntry.Type'('OP_TUPLE_SZ', Bin) ->
    <<Bin/binary, 10>>;
'e_enum_LogEntry.Type'('OP_TUPLE_NOT_SZ', Bin) ->
    <<Bin/binary, 11>>;
'e_enum_LogEntry.Type'('OP_TUPLE_NOT_TPL', Bin) ->
    <<Bin/binary, 12>>;
'e_enum_LogEntry.Type'('OP_LIST_NON_EMPTY', Bin) ->
    <<Bin/binary, 13>>;
'e_enum_LogEntry.Type'('OP_LIST_EMPTY', Bin) ->
    <<Bin/binary, 14>>;
'e_enum_LogEntry.Type'('OP_LIST_NOT_LST', Bin) ->
    <<Bin/binary, 15>>;
'e_enum_LogEntry.Type'('OP_SPAWN', Bin) ->
    <<Bin/binary, 16>>;
'e_enum_LogEntry.Type'('OP_SPAWNED', Bin) ->
    <<Bin/binary, 17>>;
'e_enum_LogEntry.Type'('OP_MSG_SEND', Bin) ->
    <<Bin/binary, 18>>;
'e_enum_LogEntry.Type'('OP_MSG_RECEIVE', Bin) ->
    <<Bin/binary, 19>>;
'e_enum_LogEntry.Type'('OP_MSG_CONSUME', Bin) ->
    <<Bin/binary, 20>>;
'e_enum_LogEntry.Type'('OP_UNFOLD_TUPLE', Bin) ->
    <<Bin/binary, 21>>;
'e_enum_LogEntry.Type'('OP_UNFOLD_LIST', Bin) ->
    <<Bin/binary, 22>>;
'e_enum_LogEntry.Type'('OP_BOGUS', Bin) ->
    <<Bin/binary, 23>>;
'e_enum_LogEntry.Type'('OP_FLOAT', Bin) ->
    <<Bin/binary, 24>>;
'e_enum_LogEntry.Type'('OP_LIST_TO_TUPLE', Bin) ->
    <<Bin/binary, 25>>;
'e_enum_LogEntry.Type'('OP_TUPLE_TO_LIST', Bin) ->
    <<Bin/binary, 26>>;
'e_enum_LogEntry.Type'('OP_IS_INTEGER', Bin) ->
    <<Bin/binary, 27>>;
'e_enum_LogEntry.Type'('OP_IS_ATOM', Bin) ->
    <<Bin/binary, 28>>;
'e_enum_LogEntry.Type'('OP_IS_FLOAT', Bin) ->
    <<Bin/binary, 29>>;
'e_enum_LogEntry.Type'('OP_IS_LIST', Bin) ->
    <<Bin/binary, 30>>;
'e_enum_LogEntry.Type'('OP_IS_TUPLE', Bin) ->
    <<Bin/binary, 31>>;
'e_enum_LogEntry.Type'('OP_IS_BOOLEAN', Bin) ->
    <<Bin/binary, 32>>;
'e_enum_LogEntry.Type'('OP_IS_NUMBER', Bin) ->
    <<Bin/binary, 33>>;
'e_enum_LogEntry.Type'('OP_IS_BITSTRING', Bin) ->
    <<Bin/binary, 34>>;
'e_enum_LogEntry.Type'('OP_IS_FUN', Bin) ->
    <<Bin/binary, 35>>;
'e_enum_LogEntry.Type'('OP_IS_FUN_WITH_ARITY', Bin) ->
    <<Bin/binary, 36>>;
'e_enum_LogEntry.Type'('OP_PLUS', Bin) ->
    <<Bin/binary, 37>>;
'e_enum_LogEntry.Type'('OP_MINUS', Bin) ->
    <<Bin/binary, 38>>;
'e_enum_LogEntry.Type'('OP_TIMES', Bin) ->
    <<Bin/binary, 39>>;
'e_enum_LogEntry.Type'('OP_RDIV', Bin) ->
    <<Bin/binary, 40>>;
'e_enum_LogEntry.Type'('OP_IDIV_NAT', Bin) ->
    <<Bin/binary, 41>>;
'e_enum_LogEntry.Type'('OP_REM_NAT', Bin) ->
    <<Bin/binary, 42>>;
'e_enum_LogEntry.Type'('OP_UNARY', Bin) ->
    <<Bin/binary, 43>>;
'e_enum_LogEntry.Type'('OP_POW', Bin) ->
    <<Bin/binary, 44>>;
'e_enum_LogEntry.Type'('OP_TRUNC', Bin) ->
    <<Bin/binary, 45>>;
'e_enum_LogEntry.Type'('OP_ATOM_NIL', Bin) ->
    <<Bin/binary, 46>>;
'e_enum_LogEntry.Type'('OP_ATOM_HEAD', Bin) ->
    <<Bin/binary, 47>>;
'e_enum_LogEntry.Type'('OP_ATOM_TAIL', Bin) ->
    <<Bin/binary, 48>>;
'e_enum_LogEntry.Type'('OP_HD', Bin) ->
    <<Bin/binary, 49>>;
'e_enum_LogEntry.Type'('OP_TL', Bin) ->
    <<Bin/binary, 50>>;
'e_enum_LogEntry.Type'('OP_CONS', Bin) ->
    <<Bin/binary, 51>>;
'e_enum_LogEntry.Type'('OP_TCONS', Bin) ->
    <<Bin/binary, 52>>;
'e_enum_LogEntry.Type'('OP_EQUAL', Bin) ->
    <<Bin/binary, 53>>;
'e_enum_LogEntry.Type'('OP_UNEQUAL', Bin) ->
    <<Bin/binary, 54>>;
'e_enum_LogEntry.Type'('OP_LT_INT', Bin) ->
    <<Bin/binary, 55>>;
'e_enum_LogEntry.Type'('OP_LT_FLOAT', Bin) ->
    <<Bin/binary, 56>>;
'e_enum_LogEntry.Type'('OP_MAKE_BITSTR', Bin) ->
    <<Bin/binary, 57>>;
'e_enum_LogEntry.Type'('OP_EMPTY_BITSTR', Bin) ->
    <<Bin/binary, 58>>;
'e_enum_LogEntry.Type'('OP_NONEMPTY_BITSTR', Bin) ->
    <<Bin/binary, 59>>;
'e_enum_LogEntry.Type'('OP_CONCAT_SEGS', Bin) ->
    <<Bin/binary, 60>>;
'e_enum_LogEntry.Type'('OP_BITMATCH_CONST_TRUE', Bin) ->
    <<Bin/binary, 61>>;
'e_enum_LogEntry.Type'('OP_BITMATCH_CONST_FALSE',
		       Bin) ->
    <<Bin/binary, 62>>;
'e_enum_LogEntry.Type'('OP_BITMATCH_VAR_TRUE', Bin) ->
    <<Bin/binary, 63>>;
'e_enum_LogEntry.Type'('OP_BITMATCH_VAR_FALSE', Bin) ->
    <<Bin/binary, 64>>;
'e_enum_LogEntry.Type'('OP_BAND', Bin) ->
    <<Bin/binary, 65>>;
'e_enum_LogEntry.Type'('OP_BXOR', Bin) ->
    <<Bin/binary, 66>>;
'e_enum_LogEntry.Type'('OP_BOR', Bin) ->
    <<Bin/binary, 67>>;
'e_enum_LogEntry.Type'(V, Bin) -> e_varint(V, Bin).

'e_enum_ErlangTerm.Type'('INTEGER', Bin) ->
    <<Bin/binary, 0>>;
'e_enum_ErlangTerm.Type'('FLOAT', Bin) ->
    <<Bin/binary, 1>>;
'e_enum_ErlangTerm.Type'('ATOM', Bin) ->
    <<Bin/binary, 2>>;
'e_enum_ErlangTerm.Type'('TUPLE', Bin) ->
    <<Bin/binary, 3>>;
'e_enum_ErlangTerm.Type'('LIST', Bin) ->
    <<Bin/binary, 4>>;
'e_enum_ErlangTerm.Type'('IMPROPER_LIST', Bin) ->
    <<Bin/binary, 5>>;
'e_enum_ErlangTerm.Type'('PID', Bin) ->
    <<Bin/binary, 6>>;
'e_enum_ErlangTerm.Type'('REFERENCE', Bin) ->
    <<Bin/binary, 7>>;
'e_enum_ErlangTerm.Type'('BITSTRING', Bin) ->
    <<Bin/binary, 8>>;
'e_enum_ErlangTerm.Type'('MAP', Bin) ->
    <<Bin/binary, 9>>;
'e_enum_ErlangTerm.Type'('FUN', Bin) ->
    <<Bin/binary, 10>>;
'e_enum_ErlangTerm.Type'('SYMBOLIC_VARIABLE', Bin) ->
    <<Bin/binary, 11>>;
'e_enum_ErlangTerm.Type'('SUBTERM', Bin) ->
    <<Bin/binary, 12>>;
'e_enum_ErlangTerm.Type'('ANY', Bin) ->
    <<Bin/binary, 13>>;
'e_enum_ErlangTerm.Type'(V, Bin) -> e_varint(V, Bin).

'e_enum_Spec.ErlType'('ANY', Bin) -> <<Bin/binary, 0>>;
'e_enum_Spec.ErlType'('ATOM', Bin) -> <<Bin/binary, 1>>;
'e_enum_Spec.ErlType'('ATOM_LITERAL', Bin) ->
    <<Bin/binary, 2>>;
'e_enum_Spec.ErlType'('FLOAT', Bin) ->
    <<Bin/binary, 3>>;
'e_enum_Spec.ErlType'('INTEGER', Bin) ->
    <<Bin/binary, 4>>;
'e_enum_Spec.ErlType'('INTEGER_LITERAL', Bin) ->
    <<Bin/binary, 5>>;
'e_enum_Spec.ErlType'('LIST', Bin) -> <<Bin/binary, 6>>;
'e_enum_Spec.ErlType'('NONEMPTY_LIST', Bin) ->
    <<Bin/binary, 7>>;
'e_enum_Spec.ErlType'('NIL', Bin) -> <<Bin/binary, 8>>;
'e_enum_Spec.ErlType'('BITSTRING', Bin) ->
    <<Bin/binary, 9>>;
'e_enum_Spec.ErlType'('TUPLE', Bin) ->
    <<Bin/binary, 10>>;
'e_enum_Spec.ErlType'('TUPLEDET', Bin) ->
    <<Bin/binary, 11>>;
'e_enum_Spec.ErlType'('UNION', Bin) ->
    <<Bin/binary, 12>>;
'e_enum_Spec.ErlType'('RANGE', Bin) ->
    <<Bin/binary, 13>>;
'e_enum_Spec.ErlType'('FUN', Bin) -> <<Bin/binary, 14>>;
'e_enum_Spec.ErlType'('CONS', Bin) ->
    <<Bin/binary, 15>>;
'e_enum_Spec.ErlType'('NTUPLE', Bin) ->
    <<Bin/binary, 16>>;
'e_enum_Spec.ErlType'('USERDEF', Bin) ->
    <<Bin/binary, 17>>;
'e_enum_Spec.ErlType'(V, Bin) -> e_varint(V, Bin).

e_type_int32(Value, Bin)
    when 0 =< Value, Value =< 127 ->
    <<Bin/binary, Value>>;
e_type_int32(Value, Bin) ->
    <<N:64/unsigned-native>> = <<Value:64/signed-native>>,
    e_varint(N, Bin).

e_type_bool(true, Bin) -> <<Bin/binary, 1>>;
e_type_bool(false, Bin) -> <<Bin/binary, 0>>;
e_type_bool(1, Bin) -> <<Bin/binary, 1>>;
e_type_bool(0, Bin) -> <<Bin/binary, 0>>.

e_type_string(S, Bin) ->
    Utf8 = unicode:characters_to_binary(S),
    Bin2 = e_varint(byte_size(Utf8), Bin),
    <<Bin2/binary, Utf8/binary>>.

e_varint(N, Bin) when N =< 127 -> <<Bin/binary, N>>;
e_varint(N, Bin) ->
    Bin2 = <<Bin/binary, (N band 127 bor 128)>>,
    e_varint(N bsr 7, Bin2).



decode_msg(Bin, MsgName) when is_binary(Bin) ->
    decode_msg(Bin, MsgName, []).

decode_msg(Bin, MsgName, Opts) when is_binary(Bin) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case MsgName of
      'LogEntry' -> d_msg_LogEntry(Bin, TrUserData);
      'ErlangTerm.MapEntry' ->
	  'd_msg_ErlangTerm.MapEntry'(Bin, TrUserData);
      'ErlangTerm.FunEntry' ->
	  'd_msg_ErlangTerm.FunEntry'(Bin, TrUserData);
      'ErlangTerm' -> d_msg_ErlangTerm(Bin, TrUserData);
      'Spec.TypeDef' -> 'd_msg_Spec.TypeDef'(Bin, TrUserData);
      'Spec.RangeBounds' ->
	  'd_msg_Spec.RangeBounds'(Bin, TrUserData);
      'Spec.SegmentSize' ->
	  'd_msg_Spec.SegmentSize'(Bin, TrUserData);
      'Spec.FunSig' -> 'd_msg_Spec.FunSig'(Bin, TrUserData);
      'Spec.FunDet' -> 'd_msg_Spec.FunDet'(Bin, TrUserData);
      'Spec.Type' -> 'd_msg_Spec.Type'(Bin, TrUserData);
      'Spec.TypeList' ->
	  'd_msg_Spec.TypeList'(Bin, TrUserData);
      'Spec' -> d_msg_Spec(Bin, TrUserData)
    end.



d_msg_LogEntry(Bin, TrUserData) ->
    dfp_read_field_def_LogEntry(Bin, 0, 0,
				id('OP_PARAMS', TrUserData), id([], TrUserData),
				id(false, TrUserData), id(0, TrUserData),
				id(undefined, TrUserData), TrUserData).

dfp_read_field_def_LogEntry(<<8, Rest/binary>>, Z1, Z2,
			    F1, F2, F3, F4, F5, TrUserData) ->
    d_field_LogEntry_type(Rest, Z1, Z2, F1, F2, F3, F4, F5,
			  TrUserData);
dfp_read_field_def_LogEntry(<<18, Rest/binary>>, Z1, Z2,
			    F1, F2, F3, F4, F5, TrUserData) ->
    d_field_LogEntry_arguments(Rest, Z1, Z2, F1, F2, F3, F4,
			       F5, TrUserData);
dfp_read_field_def_LogEntry(<<24, Rest/binary>>, Z1, Z2,
			    F1, F2, F3, F4, F5, TrUserData) ->
    d_field_LogEntry_is_constraint(Rest, Z1, Z2, F1, F2, F3,
				   F4, F5, TrUserData);
dfp_read_field_def_LogEntry(<<32, Rest/binary>>, Z1, Z2,
			    F1, F2, F3, F4, F5, TrUserData) ->
    d_field_LogEntry_tag(Rest, Z1, Z2, F1, F2, F3, F4, F5,
			 TrUserData);
dfp_read_field_def_LogEntry(<<42, Rest/binary>>, Z1, Z2,
			    F1, F2, F3, F4, F5, TrUserData) ->
    d_field_LogEntry_spec(Rest, Z1, Z2, F1, F2, F3, F4, F5,
			  TrUserData);
dfp_read_field_def_LogEntry(<<>>, 0, 0, F1, F2, F3, F4,
			    F5, TrUserData) ->
    #'LogEntry'{type = F1,
		arguments = lists_reverse(F2, TrUserData),
		is_constraint = F3, tag = F4, spec = F5};
dfp_read_field_def_LogEntry(Other, Z1, Z2, F1, F2, F3,
			    F4, F5, TrUserData) ->
    dg_read_field_def_LogEntry(Other, Z1, Z2, F1, F2, F3,
			       F4, F5, TrUserData).

dg_read_field_def_LogEntry(<<1:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, F3, F4, F5, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_LogEntry(Rest, N + 7, X bsl N + Acc,
			       F1, F2, F3, F4, F5, TrUserData);
dg_read_field_def_LogEntry(<<0:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, F3, F4, F5, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      8 ->
	  d_field_LogEntry_type(Rest, 0, 0, F1, F2, F3, F4, F5,
				TrUserData);
      18 ->
	  d_field_LogEntry_arguments(Rest, 0, 0, F1, F2, F3, F4,
				     F5, TrUserData);
      24 ->
	  d_field_LogEntry_is_constraint(Rest, 0, 0, F1, F2, F3,
					 F4, F5, TrUserData);
      32 ->
	  d_field_LogEntry_tag(Rest, 0, 0, F1, F2, F3, F4, F5,
			       TrUserData);
      42 ->
	  d_field_LogEntry_spec(Rest, 0, 0, F1, F2, F3, F4, F5,
				TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_LogEntry(Rest, 0, 0, F1, F2, F3, F4, F5,
				     TrUserData);
	    1 ->
		skip_64_LogEntry(Rest, 0, 0, F1, F2, F3, F4, F5,
				 TrUserData);
	    2 ->
		skip_length_delimited_LogEntry(Rest, 0, 0, F1, F2, F3,
					       F4, F5, TrUserData);
	    5 ->
		skip_32_LogEntry(Rest, 0, 0, F1, F2, F3, F4, F5,
				 TrUserData)
	  end
    end;
dg_read_field_def_LogEntry(<<>>, 0, 0, F1, F2, F3, F4,
			   F5, TrUserData) ->
    #'LogEntry'{type = F1,
		arguments = lists_reverse(F2, TrUserData),
		is_constraint = F3, tag = F4, spec = F5}.

d_field_LogEntry_type(<<1:1, X:7, Rest/binary>>, N, Acc,
		      F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    d_field_LogEntry_type(Rest, N + 7, X bsl N + Acc, F1,
			  F2, F3, F4, F5, TrUserData);
d_field_LogEntry_type(<<0:1, X:7, Rest/binary>>, N, Acc,
		      _, F2, F3, F4, F5, TrUserData) ->
    <<Tmp:32/signed-native>> = <<(X bsl N +
				    Acc):32/unsigned-native>>,
    NewFValue = 'd_enum_LogEntry.Type'(Tmp),
    dfp_read_field_def_LogEntry(Rest, 0, 0, NewFValue, F2,
				F3, F4, F5, TrUserData).


d_field_LogEntry_arguments(<<1:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    d_field_LogEntry_arguments(Rest, N + 7, X bsl N + Acc,
			       F1, F2, F3, F4, F5, TrUserData);
d_field_LogEntry_arguments(<<0:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, F3, F4, F5, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_LogEntry(Rest2, 0, 0, F1,
				cons(NewFValue, F2, TrUserData), F3, F4, F5,
				TrUserData).


d_field_LogEntry_is_constraint(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    d_field_LogEntry_is_constraint(Rest, N + 7,
				   X bsl N + Acc, F1, F2, F3, F4, F5,
				   TrUserData);
d_field_LogEntry_is_constraint(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, _, F4, F5, TrUserData) ->
    NewFValue = X bsl N + Acc =/= 0,
    dfp_read_field_def_LogEntry(Rest, 0, 0, F1, F2,
				NewFValue, F4, F5, TrUserData).


d_field_LogEntry_tag(<<1:1, X:7, Rest/binary>>, N, Acc,
		     F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    d_field_LogEntry_tag(Rest, N + 7, X bsl N + Acc, F1, F2,
			 F3, F4, F5, TrUserData);
d_field_LogEntry_tag(<<0:1, X:7, Rest/binary>>, N, Acc,
		     F1, F2, F3, _, F5, TrUserData) ->
    NewFValue = X bsl N + Acc,
    dfp_read_field_def_LogEntry(Rest, 0, 0, F1, F2, F3,
				NewFValue, F5, TrUserData).


d_field_LogEntry_spec(<<1:1, X:7, Rest/binary>>, N, Acc,
		      F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    d_field_LogEntry_spec(Rest, N + 7, X bsl N + Acc, F1,
			  F2, F3, F4, F5, TrUserData);
d_field_LogEntry_spec(<<0:1, X:7, Rest/binary>>, N, Acc,
		      F1, F2, F3, F4, F5, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_Spec(Bs, TrUserData), TrUserData),
    dfp_read_field_def_LogEntry(Rest2, 0, 0, F1, F2, F3, F4,
				if F5 == undefined -> NewFValue;
				   true ->
				       merge_msg_Spec(F5, NewFValue, TrUserData)
				end,
				TrUserData).


skip_varint_LogEntry(<<1:1, _:7, Rest/binary>>, Z1, Z2,
		     F1, F2, F3, F4, F5, TrUserData) ->
    skip_varint_LogEntry(Rest, Z1, Z2, F1, F2, F3, F4, F5,
			 TrUserData);
skip_varint_LogEntry(<<0:1, _:7, Rest/binary>>, Z1, Z2,
		     F1, F2, F3, F4, F5, TrUserData) ->
    dfp_read_field_def_LogEntry(Rest, Z1, Z2, F1, F2, F3,
				F4, F5, TrUserData).


skip_length_delimited_LogEntry(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, F3, F4, F5, TrUserData)
    when N < 57 ->
    skip_length_delimited_LogEntry(Rest, N + 7,
				   X bsl N + Acc, F1, F2, F3, F4, F5,
				   TrUserData);
skip_length_delimited_LogEntry(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, F3, F4, F5, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_LogEntry(Rest2, 0, 0, F1, F2, F3, F4,
				F5, TrUserData).


skip_32_LogEntry(<<_:32, Rest/binary>>, Z1, Z2, F1, F2,
		 F3, F4, F5, TrUserData) ->
    dfp_read_field_def_LogEntry(Rest, Z1, Z2, F1, F2, F3,
				F4, F5, TrUserData).


skip_64_LogEntry(<<_:64, Rest/binary>>, Z1, Z2, F1, F2,
		 F3, F4, F5, TrUserData) ->
    dfp_read_field_def_LogEntry(Rest, Z1, Z2, F1, F2, F3,
				F4, F5, TrUserData).


'd_msg_ErlangTerm.MapEntry'(Bin, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.MapEntry'(Bin, 0, 0,
					     id(undefined, TrUserData),
					     id(undefined, TrUserData),
					     TrUserData).

'dfp_read_field_def_ErlangTerm.MapEntry'(<<10,
					   Rest/binary>>,
					 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_ErlangTerm.MapEntry_key'(Rest, Z1, Z2, F1, F2,
				      TrUserData);
'dfp_read_field_def_ErlangTerm.MapEntry'(<<18,
					   Rest/binary>>,
					 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_ErlangTerm.MapEntry_value'(Rest, Z1, Z2, F1,
					F2, TrUserData);
'dfp_read_field_def_ErlangTerm.MapEntry'(<<>>, 0, 0, F1,
					 F2, _) ->
    #'ErlangTerm.MapEntry'{key = F1, value = F2};
'dfp_read_field_def_ErlangTerm.MapEntry'(Other, Z1, Z2,
					 F1, F2, TrUserData) ->
    'dg_read_field_def_ErlangTerm.MapEntry'(Other, Z1, Z2,
					    F1, F2, TrUserData).

'dg_read_field_def_ErlangTerm.MapEntry'(<<1:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_ErlangTerm.MapEntry'(Rest, N + 7,
					    X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_ErlangTerm.MapEntry'(<<0:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_ErlangTerm.MapEntry_key'(Rest, 0, 0, F1, F2,
					    TrUserData);
      18 ->
	  'd_field_ErlangTerm.MapEntry_value'(Rest, 0, 0, F1, F2,
					      TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_ErlangTerm.MapEntry'(Rest, 0, 0, F1, F2,
						  TrUserData);
	    1 ->
		'skip_64_ErlangTerm.MapEntry'(Rest, 0, 0, F1, F2,
					      TrUserData);
	    2 ->
		'skip_length_delimited_ErlangTerm.MapEntry'(Rest, 0, 0,
							    F1, F2, TrUserData);
	    5 ->
		'skip_32_ErlangTerm.MapEntry'(Rest, 0, 0, F1, F2,
					      TrUserData)
	  end
    end;
'dg_read_field_def_ErlangTerm.MapEntry'(<<>>, 0, 0, F1,
					F2, _) ->
    #'ErlangTerm.MapEntry'{key = F1, value = F2}.

'd_field_ErlangTerm.MapEntry_key'(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_ErlangTerm.MapEntry_key'(Rest, N + 7,
				      X bsl N + Acc, F1, F2, TrUserData);
'd_field_ErlangTerm.MapEntry_key'(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest2, 0, 0,
					     if F1 == undefined -> NewFValue;
						true ->
						    merge_msg_ErlangTerm(F1,
									 NewFValue,
									 TrUserData)
					     end,
					     F2, TrUserData).


'd_field_ErlangTerm.MapEntry_value'(<<1:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_ErlangTerm.MapEntry_value'(Rest, N + 7,
					X bsl N + Acc, F1, F2, TrUserData);
'd_field_ErlangTerm.MapEntry_value'(<<0:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest2, 0, 0,
					     F1,
					     if F2 == undefined -> NewFValue;
						true ->
						    merge_msg_ErlangTerm(F2,
									 NewFValue,
									 TrUserData)
					     end,
					     TrUserData).


'skip_varint_ErlangTerm.MapEntry'(<<1:1, _:7,
				    Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_ErlangTerm.MapEntry'(Rest, Z1, Z2, F1, F2,
				      TrUserData);
'skip_varint_ErlangTerm.MapEntry'(<<0:1, _:7,
				    Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


'skip_length_delimited_ErlangTerm.MapEntry'(<<1:1, X:7,
					      Rest/binary>>,
					    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_ErlangTerm.MapEntry'(Rest, N + 7,
						X bsl N + Acc, F1, F2,
						TrUserData);
'skip_length_delimited_ErlangTerm.MapEntry'(<<0:1, X:7,
					      Rest/binary>>,
					    N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest2, 0, 0,
					     F1, F2, TrUserData).


'skip_32_ErlangTerm.MapEntry'(<<_:32, Rest/binary>>, Z1,
			      Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


'skip_64_ErlangTerm.MapEntry'(<<_:64, Rest/binary>>, Z1,
			      Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.MapEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


'd_msg_ErlangTerm.FunEntry'(Bin, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.FunEntry'(Bin, 0, 0,
					     id([], TrUserData),
					     id(undefined, TrUserData),
					     TrUserData).

'dfp_read_field_def_ErlangTerm.FunEntry'(<<10,
					   Rest/binary>>,
					 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_ErlangTerm.FunEntry_arguments'(Rest, Z1, Z2,
					    F1, F2, TrUserData);
'dfp_read_field_def_ErlangTerm.FunEntry'(<<18,
					   Rest/binary>>,
					 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_ErlangTerm.FunEntry_value'(Rest, Z1, Z2, F1,
					F2, TrUserData);
'dfp_read_field_def_ErlangTerm.FunEntry'(<<>>, 0, 0, F1,
					 F2, TrUserData) ->
    #'ErlangTerm.FunEntry'{arguments =
			       lists_reverse(F1, TrUserData),
			   value = F2};
'dfp_read_field_def_ErlangTerm.FunEntry'(Other, Z1, Z2,
					 F1, F2, TrUserData) ->
    'dg_read_field_def_ErlangTerm.FunEntry'(Other, Z1, Z2,
					    F1, F2, TrUserData).

'dg_read_field_def_ErlangTerm.FunEntry'(<<1:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_ErlangTerm.FunEntry'(Rest, N + 7,
					    X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_ErlangTerm.FunEntry'(<<0:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_ErlangTerm.FunEntry_arguments'(Rest, 0, 0, F1,
						  F2, TrUserData);
      18 ->
	  'd_field_ErlangTerm.FunEntry_value'(Rest, 0, 0, F1, F2,
					      TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_ErlangTerm.FunEntry'(Rest, 0, 0, F1, F2,
						  TrUserData);
	    1 ->
		'skip_64_ErlangTerm.FunEntry'(Rest, 0, 0, F1, F2,
					      TrUserData);
	    2 ->
		'skip_length_delimited_ErlangTerm.FunEntry'(Rest, 0, 0,
							    F1, F2, TrUserData);
	    5 ->
		'skip_32_ErlangTerm.FunEntry'(Rest, 0, 0, F1, F2,
					      TrUserData)
	  end
    end;
'dg_read_field_def_ErlangTerm.FunEntry'(<<>>, 0, 0, F1,
					F2, TrUserData) ->
    #'ErlangTerm.FunEntry'{arguments =
			       lists_reverse(F1, TrUserData),
			   value = F2}.

'd_field_ErlangTerm.FunEntry_arguments'(<<1:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_ErlangTerm.FunEntry_arguments'(Rest, N + 7,
					    X bsl N + Acc, F1, F2, TrUserData);
'd_field_ErlangTerm.FunEntry_arguments'(<<0:1, X:7,
					  Rest/binary>>,
					N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest2, 0, 0,
					     cons(NewFValue, F1, TrUserData),
					     F2, TrUserData).


'd_field_ErlangTerm.FunEntry_value'(<<1:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_ErlangTerm.FunEntry_value'(Rest, N + 7,
					X bsl N + Acc, F1, F2, TrUserData);
'd_field_ErlangTerm.FunEntry_value'(<<0:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest2, 0, 0,
					     F1,
					     if F2 == undefined -> NewFValue;
						true ->
						    merge_msg_ErlangTerm(F2,
									 NewFValue,
									 TrUserData)
					     end,
					     TrUserData).


'skip_varint_ErlangTerm.FunEntry'(<<1:1, _:7,
				    Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_ErlangTerm.FunEntry'(Rest, Z1, Z2, F1, F2,
				      TrUserData);
'skip_varint_ErlangTerm.FunEntry'(<<0:1, _:7,
				    Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


'skip_length_delimited_ErlangTerm.FunEntry'(<<1:1, X:7,
					      Rest/binary>>,
					    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_ErlangTerm.FunEntry'(Rest, N + 7,
						X bsl N + Acc, F1, F2,
						TrUserData);
'skip_length_delimited_ErlangTerm.FunEntry'(<<0:1, X:7,
					      Rest/binary>>,
					    N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest2, 0, 0,
					     F1, F2, TrUserData).


'skip_32_ErlangTerm.FunEntry'(<<_:32, Rest/binary>>, Z1,
			      Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


'skip_64_ErlangTerm.FunEntry'(<<_:64, Rest/binary>>, Z1,
			      Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_ErlangTerm.FunEntry'(Rest, Z1, Z2,
					     F1, F2, TrUserData).


d_msg_ErlangTerm(Bin, TrUserData) ->
    dfp_read_field_def_ErlangTerm(Bin, 0, 0,
				  id('INTEGER', TrUserData), id([], TrUserData),
				  id([], TrUserData),
				  'tr_decode_init_default_ErlangTerm.shared'([],
									     TrUserData),
				  id(undefined, TrUserData), id([], TrUserData),
				  id([], TrUserData), id([], TrUserData),
				  id([], TrUserData), id(undefined, TrUserData),
				  id(0, TrUserData), TrUserData).

dfp_read_field_def_ErlangTerm(<<8, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_type(Rest, Z1, Z2, F1, F2, F3, F4,
			    F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<18, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_value(Rest, Z1, Z2, F1, F2, F3, F4,
			     F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<26, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_subterms(Rest, Z1, Z2, F1, F2, F3,
				F4, F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<34, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_shared(Rest, Z1, Z2, F1, F2, F3, F4,
			      F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<42, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_improper_list_nil(Rest, Z1, Z2, F1,
					 F2, F3, F4, F5, F6, F7, F8, F9, F10,
					 F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<50, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_atom_chars(Rest, Z1, Z2, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<58, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_bits(Rest, Z1, Z2, F1, F2, F3, F4,
			    F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<66, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_map_entries(Rest, Z1, Z2, F1, F2, F3,
				   F4, F5, F6, F7, F8, F9, F10, F11,
				   TrUserData);
dfp_read_field_def_ErlangTerm(<<74, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_points(Rest, Z1, Z2, F1, F2, F3, F4,
			      F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<82, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_otherwise(Rest, Z1, Z2, F1, F2, F3,
				 F4, F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<88, Rest/binary>>, Z1,
			      Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData) ->
    d_field_ErlangTerm_arity(Rest, Z1, Z2, F1, F2, F3, F4,
			     F5, F6, F7, F8, F9, F10, F11, TrUserData);
dfp_read_field_def_ErlangTerm(<<>>, 0, 0, F1, F2, F3,
			      F4, F5, F6, F7, F8, F9, F10, F11, TrUserData) ->
    #'ErlangTerm'{type = F1, value = F2,
		  subterms = lists_reverse(F3, TrUserData),
		  shared =
		      'tr_decode_repeated_finalize_ErlangTerm.shared'(F4,
								      TrUserData),
		  improper_list_nil = F5,
		  atom_chars = lists_reverse(F6, TrUserData),
		  bits = lists_reverse(F7, TrUserData),
		  map_entries = lists_reverse(F8, TrUserData),
		  points = lists_reverse(F9, TrUserData), otherwise = F10,
		  arity = F11};
dfp_read_field_def_ErlangTerm(Other, Z1, Z2, F1, F2, F3,
			      F4, F5, F6, F7, F8, F9, F10, F11, TrUserData) ->
    dg_read_field_def_ErlangTerm(Other, Z1, Z2, F1, F2, F3,
				 F4, F5, F6, F7, F8, F9, F10, F11, TrUserData).

dg_read_field_def_ErlangTerm(<<1:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			     F11, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_ErlangTerm(Rest, N + 7, X bsl N + Acc,
				 F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
				 TrUserData);
dg_read_field_def_ErlangTerm(<<0:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			     F11, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      8 ->
	  d_field_ErlangTerm_type(Rest, 0, 0, F1, F2, F3, F4, F5,
				  F6, F7, F8, F9, F10, F11, TrUserData);
      18 ->
	  d_field_ErlangTerm_value(Rest, 0, 0, F1, F2, F3, F4, F5,
				   F6, F7, F8, F9, F10, F11, TrUserData);
      26 ->
	  d_field_ErlangTerm_subterms(Rest, 0, 0, F1, F2, F3, F4,
				      F5, F6, F7, F8, F9, F10, F11, TrUserData);
      34 ->
	  d_field_ErlangTerm_shared(Rest, 0, 0, F1, F2, F3, F4,
				    F5, F6, F7, F8, F9, F10, F11, TrUserData);
      42 ->
	  d_field_ErlangTerm_improper_list_nil(Rest, 0, 0, F1, F2,
					       F3, F4, F5, F6, F7, F8, F9, F10,
					       F11, TrUserData);
      50 ->
	  d_field_ErlangTerm_atom_chars(Rest, 0, 0, F1, F2, F3,
					F4, F5, F6, F7, F8, F9, F10, F11,
					TrUserData);
      58 ->
	  d_field_ErlangTerm_bits(Rest, 0, 0, F1, F2, F3, F4, F5,
				  F6, F7, F8, F9, F10, F11, TrUserData);
      66 ->
	  d_field_ErlangTerm_map_entries(Rest, 0, 0, F1, F2, F3,
					 F4, F5, F6, F7, F8, F9, F10, F11,
					 TrUserData);
      74 ->
	  d_field_ErlangTerm_points(Rest, 0, 0, F1, F2, F3, F4,
				    F5, F6, F7, F8, F9, F10, F11, TrUserData);
      82 ->
	  d_field_ErlangTerm_otherwise(Rest, 0, 0, F1, F2, F3, F4,
				       F5, F6, F7, F8, F9, F10, F11,
				       TrUserData);
      88 ->
	  d_field_ErlangTerm_arity(Rest, 0, 0, F1, F2, F3, F4, F5,
				   F6, F7, F8, F9, F10, F11, TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		skip_varint_ErlangTerm(Rest, 0, 0, F1, F2, F3, F4, F5,
				       F6, F7, F8, F9, F10, F11, TrUserData);
	    1 ->
		skip_64_ErlangTerm(Rest, 0, 0, F1, F2, F3, F4, F5, F6,
				   F7, F8, F9, F10, F11, TrUserData);
	    2 ->
		skip_length_delimited_ErlangTerm(Rest, 0, 0, F1, F2, F3,
						 F4, F5, F6, F7, F8, F9, F10,
						 F11, TrUserData);
	    5 ->
		skip_32_ErlangTerm(Rest, 0, 0, F1, F2, F3, F4, F5, F6,
				   F7, F8, F9, F10, F11, TrUserData)
	  end
    end;
dg_read_field_def_ErlangTerm(<<>>, 0, 0, F1, F2, F3, F4,
			     F5, F6, F7, F8, F9, F10, F11, TrUserData) ->
    #'ErlangTerm'{type = F1, value = F2,
		  subterms = lists_reverse(F3, TrUserData),
		  shared =
		      'tr_decode_repeated_finalize_ErlangTerm.shared'(F4,
								      TrUserData),
		  improper_list_nil = F5,
		  atom_chars = lists_reverse(F6, TrUserData),
		  bits = lists_reverse(F7, TrUserData),
		  map_entries = lists_reverse(F8, TrUserData),
		  points = lists_reverse(F9, TrUserData), otherwise = F10,
		  arity = F11}.

d_field_ErlangTerm_type(<<1:1, X:7, Rest/binary>>, N,
			Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_type(Rest, N + 7, X bsl N + Acc, F1,
			    F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			    TrUserData);
d_field_ErlangTerm_type(<<0:1, X:7, Rest/binary>>, N,
			Acc, _, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			TrUserData) ->
    <<Tmp:32/signed-native>> = <<(X bsl N +
				    Acc):32/unsigned-native>>,
    NewFValue = 'd_enum_ErlangTerm.Type'(Tmp),
    dfp_read_field_def_ErlangTerm(Rest, 0, 0, NewFValue, F2,
				  F3, F4, F5, F6, F7, F8, F9, F10, F11,
				  TrUserData).


d_field_ErlangTerm_value(<<1:1, X:7, Rest/binary>>, N,
			 Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			 TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_value(Rest, N + 7, X bsl N + Acc, F1,
			     F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			     TrUserData);
d_field_ErlangTerm_value(<<0:1, X:7, Rest/binary>>, N,
			 Acc, F1, _, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			 TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1,
				  NewFValue, F3, F4, F5, F6, F7, F8, F9, F10,
				  F11, TrUserData).


d_field_ErlangTerm_subterms(<<1:1, X:7, Rest/binary>>,
			    N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			    F11, TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_subterms(Rest, N + 7, X bsl N + Acc,
				F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
				TrUserData);
d_field_ErlangTerm_subterms(<<0:1, X:7, Rest/binary>>,
			    N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			    F11, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2,
				  cons(NewFValue, F3, TrUserData), F4, F5, F6,
				  F7, F8, F9, F10, F11, TrUserData).


d_field_ErlangTerm_shared(<<1:1, X:7, Rest/binary>>, N,
			  Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			  TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_shared(Rest, N + 7, X bsl N + Acc,
			      F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData);
d_field_ErlangTerm_shared(<<0:1, X:7, Rest/binary>>, N,
			  Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			  TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_map<string,ErlangTerm>'(Bs,
						  TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  'tr_decode_repeated_add_elem_ErlangTerm.shared'(NewFValue,
										  F4,
										  TrUserData),
				  F5, F6, F7, F8, F9, F10, F11, TrUserData).


d_field_ErlangTerm_improper_list_nil(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9,
				     F10, F11, TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_improper_list_nil(Rest, N + 7,
					 X bsl N + Acc, F1, F2, F3, F4, F5, F6,
					 F7, F8, F9, F10, F11, TrUserData);
d_field_ErlangTerm_improper_list_nil(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9,
				     F10, F11, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4,
				  if F5 == undefined -> NewFValue;
				     true ->
					 merge_msg_ErlangTerm(F5, NewFValue,
							      TrUserData)
				  end,
				  F6, F7, F8, F9, F10, F11, TrUserData).


d_field_ErlangTerm_atom_chars(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			      F11, TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_atom_chars(Rest, N + 7,
				  X bsl N + Acc, F1, F2, F3, F4, F5, F6, F7, F8,
				  F9, F10, F11, TrUserData);
d_field_ErlangTerm_atom_chars(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			      F11, TrUserData) ->
    Len = X bsl N + Acc,
    <<PackedBytes:Len/binary, Rest2/binary>> = Rest,
    NewSeq =
	d_packed_field_ErlangTerm_atom_chars(PackedBytes, 0, 0,
					     F6),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, NewSeq, F7, F8, F9, F10, F11,
				  TrUserData).


d_packed_field_ErlangTerm_atom_chars(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, AccSeq)
    when N < 57 ->
    d_packed_field_ErlangTerm_atom_chars(Rest, N + 7,
					 X bsl N + Acc, AccSeq);
d_packed_field_ErlangTerm_atom_chars(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, AccSeq) ->
    <<NewFValue:32/signed-native>> = <<(X bsl N +
					  Acc):32/unsigned-native>>,
    d_packed_field_ErlangTerm_atom_chars(Rest, 0, 0,
					 [NewFValue | AccSeq]);
d_packed_field_ErlangTerm_atom_chars(<<>>, 0, 0,
				     AccSeq) ->
    AccSeq.


d_field_ErlangTerm_bits(<<1:1, X:7, Rest/binary>>, N,
			Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_bits(Rest, N + 7, X bsl N + Acc, F1,
			    F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			    TrUserData);
d_field_ErlangTerm_bits(<<0:1, X:7, Rest/binary>>, N,
			Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			TrUserData) ->
    Len = X bsl N + Acc,
    <<PackedBytes:Len/binary, Rest2/binary>> = Rest,
    NewSeq = d_packed_field_ErlangTerm_bits(PackedBytes, 0,
					    0, F7),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, F6, NewSeq, F8, F9, F10, F11,
				  TrUserData).


d_packed_field_ErlangTerm_bits(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, AccSeq)
    when N < 57 ->
    d_packed_field_ErlangTerm_bits(Rest, N + 7,
				   X bsl N + Acc, AccSeq);
d_packed_field_ErlangTerm_bits(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, AccSeq) ->
    NewFValue = X bsl N + Acc =/= 0,
    d_packed_field_ErlangTerm_bits(Rest, 0, 0,
				   [NewFValue | AccSeq]);
d_packed_field_ErlangTerm_bits(<<>>, 0, 0, AccSeq) ->
    AccSeq.


d_field_ErlangTerm_map_entries(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			       F11, TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_map_entries(Rest, N + 7,
				   X bsl N + Acc, F1, F2, F3, F4, F5, F6, F7,
				   F8, F9, F10, F11, TrUserData);
d_field_ErlangTerm_map_entries(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			       F11, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_ErlangTerm.MapEntry'(Bs,
					       TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, F6, F7,
				  cons(NewFValue, F8, TrUserData), F9, F10, F11,
				  TrUserData).


d_field_ErlangTerm_points(<<1:1, X:7, Rest/binary>>, N,
			  Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			  TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_points(Rest, N + 7, X bsl N + Acc,
			      F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			      TrUserData);
d_field_ErlangTerm_points(<<0:1, X:7, Rest/binary>>, N,
			  Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			  TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_ErlangTerm.FunEntry'(Bs,
					       TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, F6, F7, F8,
				  cons(NewFValue, F9, TrUserData), F10, F11,
				  TrUserData).


d_field_ErlangTerm_otherwise(<<1:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			     F11, TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_otherwise(Rest, N + 7, X bsl N + Acc,
				 F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
				 TrUserData);
d_field_ErlangTerm_otherwise(<<0:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
			     F11, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9,
				  if F10 == undefined -> NewFValue;
				     true ->
					 merge_msg_ErlangTerm(F10, NewFValue,
							      TrUserData)
				  end,
				  F11, TrUserData).


d_field_ErlangTerm_arity(<<1:1, X:7, Rest/binary>>, N,
			 Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			 TrUserData)
    when N < 57 ->
    d_field_ErlangTerm_arity(Rest, N + 7, X bsl N + Acc, F1,
			     F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
			     TrUserData);
d_field_ErlangTerm_arity(<<0:1, X:7, Rest/binary>>, N,
			 Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, _,
			 TrUserData) ->
    <<NewFValue:32/signed-native>> = <<(X bsl N +
					  Acc):32/unsigned-native>>,
    dfp_read_field_def_ErlangTerm(Rest, 0, 0, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, NewFValue,
				  TrUserData).


skip_varint_ErlangTerm(<<1:1, _:7, Rest/binary>>, Z1,
		       Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
		       TrUserData) ->
    skip_varint_ErlangTerm(Rest, Z1, Z2, F1, F2, F3, F4, F5,
			   F6, F7, F8, F9, F10, F11, TrUserData);
skip_varint_ErlangTerm(<<0:1, _:7, Rest/binary>>, Z1,
		       Z2, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11,
		       TrUserData) ->
    dfp_read_field_def_ErlangTerm(Rest, Z1, Z2, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, F11, TrUserData).


skip_length_delimited_ErlangTerm(<<1:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9,
				 F10, F11, TrUserData)
    when N < 57 ->
    skip_length_delimited_ErlangTerm(Rest, N + 7,
				     X bsl N + Acc, F1, F2, F3, F4, F5, F6, F7,
				     F8, F9, F10, F11, TrUserData);
skip_length_delimited_ErlangTerm(<<0:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, F3, F4, F5, F6, F7, F8, F9,
				 F10, F11, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_ErlangTerm(Rest2, 0, 0, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, F11, TrUserData).


skip_32_ErlangTerm(<<_:32, Rest/binary>>, Z1, Z2, F1,
		   F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, TrUserData) ->
    dfp_read_field_def_ErlangTerm(Rest, Z1, Z2, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, F11, TrUserData).


skip_64_ErlangTerm(<<_:64, Rest/binary>>, Z1, Z2, F1,
		   F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, TrUserData) ->
    dfp_read_field_def_ErlangTerm(Rest, Z1, Z2, F1, F2, F3,
				  F4, F5, F6, F7, F8, F9, F10, F11, TrUserData).


'd_msg_Spec.TypeDef'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.TypeDef'(Bin, 0, 0,
				      id([], TrUserData),
				      id(undefined, TrUserData), TrUserData).

'dfp_read_field_def_Spec.TypeDef'(<<10, Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.TypeDef_name'(Rest, Z1, Z2, F1, F2,
				TrUserData);
'dfp_read_field_def_Spec.TypeDef'(<<18, Rest/binary>>,
				  Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.TypeDef_definition'(Rest, Z1, Z2, F1, F2,
				      TrUserData);
'dfp_read_field_def_Spec.TypeDef'(<<>>, 0, 0, F1, F2,
				  _) ->
    #'Spec.TypeDef'{name = F1, definition = F2};
'dfp_read_field_def_Spec.TypeDef'(Other, Z1, Z2, F1, F2,
				  TrUserData) ->
    'dg_read_field_def_Spec.TypeDef'(Other, Z1, Z2, F1, F2,
				     TrUserData).

'dg_read_field_def_Spec.TypeDef'(<<1:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.TypeDef'(Rest, N + 7,
				     X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_Spec.TypeDef'(<<0:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.TypeDef_name'(Rest, 0, 0, F1, F2,
				      TrUserData);
      18 ->
	  'd_field_Spec.TypeDef_definition'(Rest, 0, 0, F1, F2,
					    TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.TypeDef'(Rest, 0, 0, F1, F2,
					   TrUserData);
	    1 ->
		'skip_64_Spec.TypeDef'(Rest, 0, 0, F1, F2, TrUserData);
	    2 ->
		'skip_length_delimited_Spec.TypeDef'(Rest, 0, 0, F1, F2,
						     TrUserData);
	    5 ->
		'skip_32_Spec.TypeDef'(Rest, 0, 0, F1, F2, TrUserData)
	  end
    end;
'dg_read_field_def_Spec.TypeDef'(<<>>, 0, 0, F1, F2,
				 _) ->
    #'Spec.TypeDef'{name = F1, definition = F2}.

'd_field_Spec.TypeDef_name'(<<1:1, X:7, Rest/binary>>,
			    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.TypeDef_name'(Rest, N + 7, X bsl N + Acc,
				F1, F2, TrUserData);
'd_field_Spec.TypeDef_name'(<<0:1, X:7, Rest/binary>>,
			    N, Acc, _, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.TypeDef'(Rest2, 0, 0,
				      NewFValue, F2, TrUserData).


'd_field_Spec.TypeDef_definition'(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.TypeDef_definition'(Rest, N + 7,
				      X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.TypeDef_definition'(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.TypeDef'(Rest2, 0, 0, F1,
				      if F2 == undefined -> NewFValue;
					 true ->
					     'merge_msg_Spec.Type'(F2,
								   NewFValue,
								   TrUserData)
				      end,
				      TrUserData).


'skip_varint_Spec.TypeDef'(<<1:1, _:7, Rest/binary>>,
			   Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_Spec.TypeDef'(Rest, Z1, Z2, F1, F2,
			       TrUserData);
'skip_varint_Spec.TypeDef'(<<0:1, _:7, Rest/binary>>,
			   Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.TypeDef'(Rest, Z1, Z2, F1, F2,
				      TrUserData).


'skip_length_delimited_Spec.TypeDef'(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.TypeDef'(Rest, N + 7,
					 X bsl N + Acc, F1, F2, TrUserData);
'skip_length_delimited_Spec.TypeDef'(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.TypeDef'(Rest2, 0, 0, F1, F2,
				      TrUserData).


'skip_32_Spec.TypeDef'(<<_:32, Rest/binary>>, Z1, Z2,
		       F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.TypeDef'(Rest, Z1, Z2, F1, F2,
				      TrUserData).


'skip_64_Spec.TypeDef'(<<_:64, Rest/binary>>, Z1, Z2,
		       F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.TypeDef'(Rest, Z1, Z2, F1, F2,
				      TrUserData).


'd_msg_Spec.RangeBounds'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.RangeBounds'(Bin, 0, 0,
					  id([], TrUserData),
					  id([], TrUserData), TrUserData).

'dfp_read_field_def_Spec.RangeBounds'(<<10,
					Rest/binary>>,
				      Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.RangeBounds_lower_bound'(Rest, Z1, Z2, F1,
					   F2, TrUserData);
'dfp_read_field_def_Spec.RangeBounds'(<<18,
					Rest/binary>>,
				      Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.RangeBounds_upper_bound'(Rest, Z1, Z2, F1,
					   F2, TrUserData);
'dfp_read_field_def_Spec.RangeBounds'(<<>>, 0, 0, F1,
				      F2, _) ->
    #'Spec.RangeBounds'{lower_bound = F1, upper_bound = F2};
'dfp_read_field_def_Spec.RangeBounds'(Other, Z1, Z2, F1,
				      F2, TrUserData) ->
    'dg_read_field_def_Spec.RangeBounds'(Other, Z1, Z2, F1,
					 F2, TrUserData).

'dg_read_field_def_Spec.RangeBounds'(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.RangeBounds'(Rest, N + 7,
					 X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_Spec.RangeBounds'(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.RangeBounds_lower_bound'(Rest, 0, 0, F1,
						 F2, TrUserData);
      18 ->
	  'd_field_Spec.RangeBounds_upper_bound'(Rest, 0, 0, F1,
						 F2, TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.RangeBounds'(Rest, 0, 0, F1, F2,
					       TrUserData);
	    1 ->
		'skip_64_Spec.RangeBounds'(Rest, 0, 0, F1, F2,
					   TrUserData);
	    2 ->
		'skip_length_delimited_Spec.RangeBounds'(Rest, 0, 0, F1,
							 F2, TrUserData);
	    5 ->
		'skip_32_Spec.RangeBounds'(Rest, 0, 0, F1, F2,
					   TrUserData)
	  end
    end;
'dg_read_field_def_Spec.RangeBounds'(<<>>, 0, 0, F1, F2,
				     _) ->
    #'Spec.RangeBounds'{lower_bound = F1, upper_bound = F2}.

'd_field_Spec.RangeBounds_lower_bound'(<<1:1, X:7,
					 Rest/binary>>,
				       N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.RangeBounds_lower_bound'(Rest, N + 7,
					   X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.RangeBounds_lower_bound'(<<0:1, X:7,
					 Rest/binary>>,
				       N, Acc, _, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.RangeBounds'(Rest2, 0, 0,
					  NewFValue, F2, TrUserData).


'd_field_Spec.RangeBounds_upper_bound'(<<1:1, X:7,
					 Rest/binary>>,
				       N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.RangeBounds_upper_bound'(Rest, N + 7,
					   X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.RangeBounds_upper_bound'(<<0:1, X:7,
					 Rest/binary>>,
				       N, Acc, F1, _, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.RangeBounds'(Rest2, 0, 0, F1,
					  NewFValue, TrUserData).


'skip_varint_Spec.RangeBounds'(<<1:1, _:7,
				 Rest/binary>>,
			       Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_Spec.RangeBounds'(Rest, Z1, Z2, F1, F2,
				   TrUserData);
'skip_varint_Spec.RangeBounds'(<<0:1, _:7,
				 Rest/binary>>,
			       Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.RangeBounds'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'skip_length_delimited_Spec.RangeBounds'(<<1:1, X:7,
					   Rest/binary>>,
					 N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.RangeBounds'(Rest, N + 7,
					     X bsl N + Acc, F1, F2, TrUserData);
'skip_length_delimited_Spec.RangeBounds'(<<0:1, X:7,
					   Rest/binary>>,
					 N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.RangeBounds'(Rest2, 0, 0, F1,
					  F2, TrUserData).


'skip_32_Spec.RangeBounds'(<<_:32, Rest/binary>>, Z1,
			   Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.RangeBounds'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'skip_64_Spec.RangeBounds'(<<_:64, Rest/binary>>, Z1,
			   Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.RangeBounds'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'd_msg_Spec.SegmentSize'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.SegmentSize'(Bin, 0, 0,
					  id([], TrUserData),
					  id([], TrUserData), TrUserData).

'dfp_read_field_def_Spec.SegmentSize'(<<10,
					Rest/binary>>,
				      Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.SegmentSize_m'(Rest, Z1, Z2, F1, F2,
				 TrUserData);
'dfp_read_field_def_Spec.SegmentSize'(<<18,
					Rest/binary>>,
				      Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.SegmentSize_n'(Rest, Z1, Z2, F1, F2,
				 TrUserData);
'dfp_read_field_def_Spec.SegmentSize'(<<>>, 0, 0, F1,
				      F2, _) ->
    #'Spec.SegmentSize'{m = F1, n = F2};
'dfp_read_field_def_Spec.SegmentSize'(Other, Z1, Z2, F1,
				      F2, TrUserData) ->
    'dg_read_field_def_Spec.SegmentSize'(Other, Z1, Z2, F1,
					 F2, TrUserData).

'dg_read_field_def_Spec.SegmentSize'(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.SegmentSize'(Rest, N + 7,
					 X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_Spec.SegmentSize'(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.SegmentSize_m'(Rest, 0, 0, F1, F2,
				       TrUserData);
      18 ->
	  'd_field_Spec.SegmentSize_n'(Rest, 0, 0, F1, F2,
				       TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.SegmentSize'(Rest, 0, 0, F1, F2,
					       TrUserData);
	    1 ->
		'skip_64_Spec.SegmentSize'(Rest, 0, 0, F1, F2,
					   TrUserData);
	    2 ->
		'skip_length_delimited_Spec.SegmentSize'(Rest, 0, 0, F1,
							 F2, TrUserData);
	    5 ->
		'skip_32_Spec.SegmentSize'(Rest, 0, 0, F1, F2,
					   TrUserData)
	  end
    end;
'dg_read_field_def_Spec.SegmentSize'(<<>>, 0, 0, F1, F2,
				     _) ->
    #'Spec.SegmentSize'{m = F1, n = F2}.

'd_field_Spec.SegmentSize_m'(<<1:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.SegmentSize_m'(Rest, N + 7, X bsl N + Acc,
				 F1, F2, TrUserData);
'd_field_Spec.SegmentSize_m'(<<0:1, X:7, Rest/binary>>,
			     N, Acc, _, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.SegmentSize'(Rest2, 0, 0,
					  NewFValue, F2, TrUserData).


'd_field_Spec.SegmentSize_n'(<<1:1, X:7, Rest/binary>>,
			     N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.SegmentSize_n'(Rest, N + 7, X bsl N + Acc,
				 F1, F2, TrUserData);
'd_field_Spec.SegmentSize_n'(<<0:1, X:7, Rest/binary>>,
			     N, Acc, F1, _, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.SegmentSize'(Rest2, 0, 0, F1,
					  NewFValue, TrUserData).


'skip_varint_Spec.SegmentSize'(<<1:1, _:7,
				 Rest/binary>>,
			       Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_Spec.SegmentSize'(Rest, Z1, Z2, F1, F2,
				   TrUserData);
'skip_varint_Spec.SegmentSize'(<<0:1, _:7,
				 Rest/binary>>,
			       Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.SegmentSize'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'skip_length_delimited_Spec.SegmentSize'(<<1:1, X:7,
					   Rest/binary>>,
					 N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.SegmentSize'(Rest, N + 7,
					     X bsl N + Acc, F1, F2, TrUserData);
'skip_length_delimited_Spec.SegmentSize'(<<0:1, X:7,
					   Rest/binary>>,
					 N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.SegmentSize'(Rest2, 0, 0, F1,
					  F2, TrUserData).


'skip_32_Spec.SegmentSize'(<<_:32, Rest/binary>>, Z1,
			   Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.SegmentSize'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'skip_64_Spec.SegmentSize'(<<_:64, Rest/binary>>, Z1,
			   Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.SegmentSize'(Rest, Z1, Z2, F1,
					  F2, TrUserData).


'd_msg_Spec.FunSig'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.FunSig'(Bin, 0, 0,
				     id(undefined, TrUserData), TrUserData).

'dfp_read_field_def_Spec.FunSig'(<<10, Rest/binary>>,
				 Z1, Z2, F1, TrUserData) ->
    'd_field_Spec.FunSig_complete'(Rest, Z1, Z2, F1,
				   TrUserData);
'dfp_read_field_def_Spec.FunSig'(<<18, Rest/binary>>,
				 Z1, Z2, F1, TrUserData) ->
    'd_field_Spec.FunSig_just_return'(Rest, Z1, Z2, F1,
				      TrUserData);
'dfp_read_field_def_Spec.FunSig'(<<>>, 0, 0, F1, _) ->
    #'Spec.FunSig'{signature = F1};
'dfp_read_field_def_Spec.FunSig'(Other, Z1, Z2, F1,
				 TrUserData) ->
    'dg_read_field_def_Spec.FunSig'(Other, Z1, Z2, F1,
				    TrUserData).

'dg_read_field_def_Spec.FunSig'(<<1:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.FunSig'(Rest, N + 7,
				    X bsl N + Acc, F1, TrUserData);
'dg_read_field_def_Spec.FunSig'(<<0:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.FunSig_complete'(Rest, 0, 0, F1,
					 TrUserData);
      18 ->
	  'd_field_Spec.FunSig_just_return'(Rest, 0, 0, F1,
					    TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.FunSig'(Rest, 0, 0, F1, TrUserData);
	    1 -> 'skip_64_Spec.FunSig'(Rest, 0, 0, F1, TrUserData);
	    2 ->
		'skip_length_delimited_Spec.FunSig'(Rest, 0, 0, F1,
						    TrUserData);
	    5 -> 'skip_32_Spec.FunSig'(Rest, 0, 0, F1, TrUserData)
	  end
    end;
'dg_read_field_def_Spec.FunSig'(<<>>, 0, 0, F1, _) ->
    #'Spec.FunSig'{signature = F1}.

'd_field_Spec.FunSig_complete'(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, TrUserData)
    when N < 57 ->
    'd_field_Spec.FunSig_complete'(Rest, N + 7,
				   X bsl N + Acc, F1, TrUserData);
'd_field_Spec.FunSig_complete'(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.FunDet'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.FunSig'(Rest2, 0, 0,
				     case F1 of
				       undefined -> {complete, NewFValue};
				       {complete, MVF1} ->
					   {complete,
					    'merge_msg_Spec.FunDet'(MVF1,
								    NewFValue,
								    TrUserData)};
				       _ -> {complete, NewFValue}
				     end,
				     TrUserData).


'd_field_Spec.FunSig_just_return'(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, TrUserData)
    when N < 57 ->
    'd_field_Spec.FunSig_just_return'(Rest, N + 7,
				      X bsl N + Acc, F1, TrUserData);
'd_field_Spec.FunSig_just_return'(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.FunSig'(Rest2, 0, 0,
				     case F1 of
				       undefined -> {just_return, NewFValue};
				       {just_return, MVF1} ->
					   {just_return,
					    'merge_msg_Spec.Type'(MVF1,
								  NewFValue,
								  TrUserData)};
				       _ -> {just_return, NewFValue}
				     end,
				     TrUserData).


'skip_varint_Spec.FunSig'(<<1:1, _:7, Rest/binary>>, Z1,
			  Z2, F1, TrUserData) ->
    'skip_varint_Spec.FunSig'(Rest, Z1, Z2, F1, TrUserData);
'skip_varint_Spec.FunSig'(<<0:1, _:7, Rest/binary>>, Z1,
			  Z2, F1, TrUserData) ->
    'dfp_read_field_def_Spec.FunSig'(Rest, Z1, Z2, F1,
				     TrUserData).


'skip_length_delimited_Spec.FunSig'(<<1:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.FunSig'(Rest, N + 7,
					X bsl N + Acc, F1, TrUserData);
'skip_length_delimited_Spec.FunSig'(<<0:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.FunSig'(Rest2, 0, 0, F1,
				     TrUserData).


'skip_32_Spec.FunSig'(<<_:32, Rest/binary>>, Z1, Z2, F1,
		      TrUserData) ->
    'dfp_read_field_def_Spec.FunSig'(Rest, Z1, Z2, F1,
				     TrUserData).


'skip_64_Spec.FunSig'(<<_:64, Rest/binary>>, Z1, Z2, F1,
		      TrUserData) ->
    'dfp_read_field_def_Spec.FunSig'(Rest, Z1, Z2, F1,
				     TrUserData).


'd_msg_Spec.FunDet'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.FunDet'(Bin, 0, 0,
				     id([], TrUserData),
				     id(undefined, TrUserData), TrUserData).

'dfp_read_field_def_Spec.FunDet'(<<10, Rest/binary>>,
				 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.FunDet_parameters'(Rest, Z1, Z2, F1, F2,
				     TrUserData);
'dfp_read_field_def_Spec.FunDet'(<<18, Rest/binary>>,
				 Z1, Z2, F1, F2, TrUserData) ->
    'd_field_Spec.FunDet_return_value'(Rest, Z1, Z2, F1, F2,
				       TrUserData);
'dfp_read_field_def_Spec.FunDet'(<<>>, 0, 0, F1, F2,
				 TrUserData) ->
    #'Spec.FunDet'{parameters =
		       lists_reverse(F1, TrUserData),
		   return_value = F2};
'dfp_read_field_def_Spec.FunDet'(Other, Z1, Z2, F1, F2,
				 TrUserData) ->
    'dg_read_field_def_Spec.FunDet'(Other, Z1, Z2, F1, F2,
				    TrUserData).

'dg_read_field_def_Spec.FunDet'(<<1:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.FunDet'(Rest, N + 7,
				    X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_Spec.FunDet'(<<0:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.FunDet_parameters'(Rest, 0, 0, F1, F2,
					   TrUserData);
      18 ->
	  'd_field_Spec.FunDet_return_value'(Rest, 0, 0, F1, F2,
					     TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.FunDet'(Rest, 0, 0, F1, F2,
					  TrUserData);
	    1 ->
		'skip_64_Spec.FunDet'(Rest, 0, 0, F1, F2, TrUserData);
	    2 ->
		'skip_length_delimited_Spec.FunDet'(Rest, 0, 0, F1, F2,
						    TrUserData);
	    5 ->
		'skip_32_Spec.FunDet'(Rest, 0, 0, F1, F2, TrUserData)
	  end
    end;
'dg_read_field_def_Spec.FunDet'(<<>>, 0, 0, F1, F2,
				TrUserData) ->
    #'Spec.FunDet'{parameters =
		       lists_reverse(F1, TrUserData),
		   return_value = F2}.

'd_field_Spec.FunDet_parameters'(<<1:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.FunDet_parameters'(Rest, N + 7,
				     X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.FunDet_parameters'(<<0:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.FunDet'(Rest2, 0, 0,
				     cons(NewFValue, F1, TrUserData), F2,
				     TrUserData).


'd_field_Spec.FunDet_return_value'(<<1:1, X:7,
				     Rest/binary>>,
				   N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.FunDet_return_value'(Rest, N + 7,
				       X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.FunDet_return_value'(<<0:1, X:7,
				     Rest/binary>>,
				   N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.FunDet'(Rest2, 0, 0, F1,
				     if F2 == undefined -> NewFValue;
					true ->
					    'merge_msg_Spec.Type'(F2, NewFValue,
								  TrUserData)
				     end,
				     TrUserData).


'skip_varint_Spec.FunDet'(<<1:1, _:7, Rest/binary>>, Z1,
			  Z2, F1, F2, TrUserData) ->
    'skip_varint_Spec.FunDet'(Rest, Z1, Z2, F1, F2,
			      TrUserData);
'skip_varint_Spec.FunDet'(<<0:1, _:7, Rest/binary>>, Z1,
			  Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.FunDet'(Rest, Z1, Z2, F1, F2,
				     TrUserData).


'skip_length_delimited_Spec.FunDet'(<<1:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.FunDet'(Rest, N + 7,
					X bsl N + Acc, F1, F2, TrUserData);
'skip_length_delimited_Spec.FunDet'(<<0:1, X:7,
				      Rest/binary>>,
				    N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.FunDet'(Rest2, 0, 0, F1, F2,
				     TrUserData).


'skip_32_Spec.FunDet'(<<_:32, Rest/binary>>, Z1, Z2, F1,
		      F2, TrUserData) ->
    'dfp_read_field_def_Spec.FunDet'(Rest, Z1, Z2, F1, F2,
				     TrUserData).


'skip_64_Spec.FunDet'(<<_:64, Rest/binary>>, Z1, Z2, F1,
		      F2, TrUserData) ->
    'dfp_read_field_def_Spec.FunDet'(Rest, Z1, Z2, F1, F2,
				     TrUserData).


'd_msg_Spec.Type'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.Type'(Bin, 0, 0,
				   id('ANY', TrUserData),
				   id(undefined, TrUserData), TrUserData).

'dfp_read_field_def_Spec.Type'(<<8, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_type'(Rest, Z1, Z2, F1, F2,
			     TrUserData);
'dfp_read_field_def_Spec.Type'(<<18, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_literal'(Rest, Z1, Z2, F1, F2,
				TrUserData);
'dfp_read_field_def_Spec.Type'(<<26, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_range_bounds'(Rest, Z1, Z2, F1, F2,
				     TrUserData);
'dfp_read_field_def_Spec.Type'(<<34, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_segment_size'(Rest, Z1, Z2, F1, F2,
				     TrUserData);
'dfp_read_field_def_Spec.Type'(<<42, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_inner_type'(Rest, Z1, Z2, F1, F2,
				   TrUserData);
'dfp_read_field_def_Spec.Type'(<<50, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_inner_types'(Rest, Z1, Z2, F1, F2,
				    TrUserData);
'dfp_read_field_def_Spec.Type'(<<58, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_fun'(Rest, Z1, Z2, F1, F2,
			    TrUserData);
'dfp_read_field_def_Spec.Type'(<<64, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_ntuple_size'(Rest, Z1, Z2, F1, F2,
				    TrUserData);
'dfp_read_field_def_Spec.Type'(<<74, Rest/binary>>, Z1,
			       Z2, F1, F2, TrUserData) ->
    'd_field_Spec.Type_type_name'(Rest, Z1, Z2, F1, F2,
				  TrUserData);
'dfp_read_field_def_Spec.Type'(<<>>, 0, 0, F1, F2, _) ->
    #'Spec.Type'{type = F1, arg = F2};
'dfp_read_field_def_Spec.Type'(Other, Z1, Z2, F1, F2,
			       TrUserData) ->
    'dg_read_field_def_Spec.Type'(Other, Z1, Z2, F1, F2,
				  TrUserData).

'dg_read_field_def_Spec.Type'(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.Type'(Rest, N + 7,
				  X bsl N + Acc, F1, F2, TrUserData);
'dg_read_field_def_Spec.Type'(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      8 ->
	  'd_field_Spec.Type_type'(Rest, 0, 0, F1, F2,
				   TrUserData);
      18 ->
	  'd_field_Spec.Type_literal'(Rest, 0, 0, F1, F2,
				      TrUserData);
      26 ->
	  'd_field_Spec.Type_range_bounds'(Rest, 0, 0, F1, F2,
					   TrUserData);
      34 ->
	  'd_field_Spec.Type_segment_size'(Rest, 0, 0, F1, F2,
					   TrUserData);
      42 ->
	  'd_field_Spec.Type_inner_type'(Rest, 0, 0, F1, F2,
					 TrUserData);
      50 ->
	  'd_field_Spec.Type_inner_types'(Rest, 0, 0, F1, F2,
					  TrUserData);
      58 ->
	  'd_field_Spec.Type_fun'(Rest, 0, 0, F1, F2, TrUserData);
      64 ->
	  'd_field_Spec.Type_ntuple_size'(Rest, 0, 0, F1, F2,
					  TrUserData);
      74 ->
	  'd_field_Spec.Type_type_name'(Rest, 0, 0, F1, F2,
					TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.Type'(Rest, 0, 0, F1, F2, TrUserData);
	    1 ->
		'skip_64_Spec.Type'(Rest, 0, 0, F1, F2, TrUserData);
	    2 ->
		'skip_length_delimited_Spec.Type'(Rest, 0, 0, F1, F2,
						  TrUserData);
	    5 -> 'skip_32_Spec.Type'(Rest, 0, 0, F1, F2, TrUserData)
	  end
    end;
'dg_read_field_def_Spec.Type'(<<>>, 0, 0, F1, F2, _) ->
    #'Spec.Type'{type = F1, arg = F2}.

'd_field_Spec.Type_type'(<<1:1, X:7, Rest/binary>>, N,
			 Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_type'(Rest, N + 7, X bsl N + Acc, F1,
			     F2, TrUserData);
'd_field_Spec.Type_type'(<<0:1, X:7, Rest/binary>>, N,
			 Acc, _, F2, TrUserData) ->
    <<Tmp:32/signed-native>> = <<(X bsl N +
				    Acc):32/unsigned-native>>,
    NewFValue = 'd_enum_Spec.ErlType'(Tmp),
    'dfp_read_field_def_Spec.Type'(Rest, 0, 0, NewFValue,
				   F2, TrUserData).


'd_field_Spec.Type_literal'(<<1:1, X:7, Rest/binary>>,
			    N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_literal'(Rest, N + 7, X bsl N + Acc,
				F1, F2, TrUserData);
'd_field_Spec.Type_literal'(<<0:1, X:7, Rest/binary>>,
			    N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {literal, NewFValue};
				     {literal, MVF2} ->
					 {literal,
					  merge_msg_ErlangTerm(MVF2, NewFValue,
							       TrUserData)};
				     _ -> {literal, NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_range_bounds'(<<1:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_range_bounds'(Rest, N + 7,
				     X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_range_bounds'(<<0:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.RangeBounds'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {range_bounds, NewFValue};
				     {range_bounds, MVF2} ->
					 {range_bounds,
					  'merge_msg_Spec.RangeBounds'(MVF2,
								       NewFValue,
								       TrUserData)};
				     _ -> {range_bounds, NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_segment_size'(<<1:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_segment_size'(Rest, N + 7,
				     X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_segment_size'(<<0:1, X:7,
				   Rest/binary>>,
				 N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.SegmentSize'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {segment_size, NewFValue};
				     {segment_size, MVF2} ->
					 {segment_size,
					  'merge_msg_Spec.SegmentSize'(MVF2,
								       NewFValue,
								       TrUserData)};
				     _ -> {segment_size, NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_inner_type'(<<1:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_inner_type'(Rest, N + 7,
				   X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_inner_type'(<<0:1, X:7,
				 Rest/binary>>,
			       N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {inner_type, NewFValue};
				     {inner_type, MVF2} ->
					 {inner_type,
					  'merge_msg_Spec.Type'(MVF2, NewFValue,
								TrUserData)};
				     _ -> {inner_type, NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_inner_types'(<<1:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_inner_types'(Rest, N + 7,
				    X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_inner_types'(<<0:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.TypeList'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {inner_types, NewFValue};
				     {inner_types, MVF2} ->
					 {inner_types,
					  'merge_msg_Spec.TypeList'(MVF2,
								    NewFValue,
								    TrUserData)};
				     _ -> {inner_types, NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_fun'(<<1:1, X:7, Rest/binary>>, N,
			Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_fun'(Rest, N + 7, X bsl N + Acc, F1,
			    F2, TrUserData);
'd_field_Spec.Type_fun'(<<0:1, X:7, Rest/binary>>, N,
			Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.FunSig'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   case F2 of
				     undefined -> {'fun', NewFValue};
				     {'fun', MVF2} ->
					 {'fun',
					  'merge_msg_Spec.FunSig'(MVF2,
								  NewFValue,
								  TrUserData)};
				     _ -> {'fun', NewFValue}
				   end,
				   TrUserData).


'd_field_Spec.Type_ntuple_size'(<<1:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_ntuple_size'(Rest, N + 7,
				    X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_ntuple_size'(<<0:1, X:7,
				  Rest/binary>>,
				N, Acc, F1, _, TrUserData) ->
    NewFValue = X bsl N + Acc,
    'dfp_read_field_def_Spec.Type'(Rest, 0, 0, F1,
				   {ntuple_size, NewFValue}, TrUserData).


'd_field_Spec.Type_type_name'(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_Spec.Type_type_name'(Rest, N + 7,
				  X bsl N + Acc, F1, F2, TrUserData);
'd_field_Spec.Type_type_name'(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F1, _, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1,
				   {type_name, NewFValue}, TrUserData).


'skip_varint_Spec.Type'(<<1:1, _:7, Rest/binary>>, Z1,
			Z2, F1, F2, TrUserData) ->
    'skip_varint_Spec.Type'(Rest, Z1, Z2, F1, F2,
			    TrUserData);
'skip_varint_Spec.Type'(<<0:1, _:7, Rest/binary>>, Z1,
			Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_Spec.Type'(Rest, Z1, Z2, F1, F2,
				   TrUserData).


'skip_length_delimited_Spec.Type'(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.Type'(Rest, N + 7,
				      X bsl N + Acc, F1, F2, TrUserData);
'skip_length_delimited_Spec.Type'(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.Type'(Rest2, 0, 0, F1, F2,
				   TrUserData).


'skip_32_Spec.Type'(<<_:32, Rest/binary>>, Z1, Z2, F1,
		    F2, TrUserData) ->
    'dfp_read_field_def_Spec.Type'(Rest, Z1, Z2, F1, F2,
				   TrUserData).


'skip_64_Spec.Type'(<<_:64, Rest/binary>>, Z1, Z2, F1,
		    F2, TrUserData) ->
    'dfp_read_field_def_Spec.Type'(Rest, Z1, Z2, F1, F2,
				   TrUserData).


'd_msg_Spec.TypeList'(Bin, TrUserData) ->
    'dfp_read_field_def_Spec.TypeList'(Bin, 0, 0,
				       id([], TrUserData), TrUserData).

'dfp_read_field_def_Spec.TypeList'(<<10, Rest/binary>>,
				   Z1, Z2, F1, TrUserData) ->
    'd_field_Spec.TypeList_types'(Rest, Z1, Z2, F1,
				  TrUserData);
'dfp_read_field_def_Spec.TypeList'(<<>>, 0, 0, F1,
				   TrUserData) ->
    #'Spec.TypeList'{types = lists_reverse(F1, TrUserData)};
'dfp_read_field_def_Spec.TypeList'(Other, Z1, Z2, F1,
				   TrUserData) ->
    'dg_read_field_def_Spec.TypeList'(Other, Z1, Z2, F1,
				      TrUserData).

'dg_read_field_def_Spec.TypeList'(<<1:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_Spec.TypeList'(Rest, N + 7,
				      X bsl N + Acc, F1, TrUserData);
'dg_read_field_def_Spec.TypeList'(<<0:1, X:7,
				    Rest/binary>>,
				  N, Acc, F1, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_Spec.TypeList_types'(Rest, 0, 0, F1,
					TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_Spec.TypeList'(Rest, 0, 0, F1, TrUserData);
	    1 ->
		'skip_64_Spec.TypeList'(Rest, 0, 0, F1, TrUserData);
	    2 ->
		'skip_length_delimited_Spec.TypeList'(Rest, 0, 0, F1,
						      TrUserData);
	    5 -> 'skip_32_Spec.TypeList'(Rest, 0, 0, F1, TrUserData)
	  end
    end;
'dg_read_field_def_Spec.TypeList'(<<>>, 0, 0, F1,
				  TrUserData) ->
    #'Spec.TypeList'{types = lists_reverse(F1, TrUserData)}.

'd_field_Spec.TypeList_types'(<<1:1, X:7, Rest/binary>>,
			      N, Acc, F1, TrUserData)
    when N < 57 ->
    'd_field_Spec.TypeList_types'(Rest, N + 7,
				  X bsl N + Acc, F1, TrUserData);
'd_field_Spec.TypeList_types'(<<0:1, X:7, Rest/binary>>,
			      N, Acc, F1, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.Type'(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_Spec.TypeList'(Rest2, 0, 0,
				       cons(NewFValue, F1, TrUserData),
				       TrUserData).


'skip_varint_Spec.TypeList'(<<1:1, _:7, Rest/binary>>,
			    Z1, Z2, F1, TrUserData) ->
    'skip_varint_Spec.TypeList'(Rest, Z1, Z2, F1,
				TrUserData);
'skip_varint_Spec.TypeList'(<<0:1, _:7, Rest/binary>>,
			    Z1, Z2, F1, TrUserData) ->
    'dfp_read_field_def_Spec.TypeList'(Rest, Z1, Z2, F1,
				       TrUserData).


'skip_length_delimited_Spec.TypeList'(<<1:1, X:7,
					Rest/binary>>,
				      N, Acc, F1, TrUserData)
    when N < 57 ->
    'skip_length_delimited_Spec.TypeList'(Rest, N + 7,
					  X bsl N + Acc, F1, TrUserData);
'skip_length_delimited_Spec.TypeList'(<<0:1, X:7,
					Rest/binary>>,
				      N, Acc, F1, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_Spec.TypeList'(Rest2, 0, 0, F1,
				       TrUserData).


'skip_32_Spec.TypeList'(<<_:32, Rest/binary>>, Z1, Z2,
			F1, TrUserData) ->
    'dfp_read_field_def_Spec.TypeList'(Rest, Z1, Z2, F1,
				       TrUserData).


'skip_64_Spec.TypeList'(<<_:64, Rest/binary>>, Z1, Z2,
			F1, TrUserData) ->
    'dfp_read_field_def_Spec.TypeList'(Rest, Z1, Z2, F1,
				       TrUserData).


d_msg_Spec(Bin, TrUserData) ->
    dfp_read_field_def_Spec(Bin, 0, 0, id([], TrUserData),
			    id([], TrUserData), TrUserData).

dfp_read_field_def_Spec(<<10, Rest/binary>>, Z1, Z2, F1,
			F2, TrUserData) ->
    d_field_Spec_clauses(Rest, Z1, Z2, F1, F2, TrUserData);
dfp_read_field_def_Spec(<<18, Rest/binary>>, Z1, Z2, F1,
			F2, TrUserData) ->
    d_field_Spec_typedefs(Rest, Z1, Z2, F1, F2, TrUserData);
dfp_read_field_def_Spec(<<>>, 0, 0, F1, F2,
			TrUserData) ->
    #'Spec'{clauses = lists_reverse(F1, TrUserData),
	    typedefs = lists_reverse(F2, TrUserData)};
dfp_read_field_def_Spec(Other, Z1, Z2, F1, F2,
			TrUserData) ->
    dg_read_field_def_Spec(Other, Z1, Z2, F1, F2,
			   TrUserData).

dg_read_field_def_Spec(<<1:1, X:7, Rest/binary>>, N,
		       Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    dg_read_field_def_Spec(Rest, N + 7, X bsl N + Acc, F1,
			   F2, TrUserData);
dg_read_field_def_Spec(<<0:1, X:7, Rest/binary>>, N,
		       Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  d_field_Spec_clauses(Rest, 0, 0, F1, F2, TrUserData);
      18 ->
	  d_field_Spec_typedefs(Rest, 0, 0, F1, F2, TrUserData);
      _ ->
	  case Key band 7 of
	    0 -> skip_varint_Spec(Rest, 0, 0, F1, F2, TrUserData);
	    1 -> skip_64_Spec(Rest, 0, 0, F1, F2, TrUserData);
	    2 ->
		skip_length_delimited_Spec(Rest, 0, 0, F1, F2,
					   TrUserData);
	    5 -> skip_32_Spec(Rest, 0, 0, F1, F2, TrUserData)
	  end
    end;
dg_read_field_def_Spec(<<>>, 0, 0, F1, F2,
		       TrUserData) ->
    #'Spec'{clauses = lists_reverse(F1, TrUserData),
	    typedefs = lists_reverse(F2, TrUserData)}.

d_field_Spec_clauses(<<1:1, X:7, Rest/binary>>, N, Acc,
		     F1, F2, TrUserData)
    when N < 57 ->
    d_field_Spec_clauses(Rest, N + 7, X bsl N + Acc, F1, F2,
			 TrUserData);
d_field_Spec_clauses(<<0:1, X:7, Rest/binary>>, N, Acc,
		     F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.FunSig'(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_Spec(Rest2, 0, 0,
			    cons(NewFValue, F1, TrUserData), F2, TrUserData).


d_field_Spec_typedefs(<<1:1, X:7, Rest/binary>>, N, Acc,
		      F1, F2, TrUserData)
    when N < 57 ->
    d_field_Spec_typedefs(Rest, N + 7, X bsl N + Acc, F1,
			  F2, TrUserData);
d_field_Spec_typedefs(<<0:1, X:7, Rest/binary>>, N, Acc,
		      F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id('d_msg_Spec.TypeDef'(Bs, TrUserData),
		   TrUserData),
    dfp_read_field_def_Spec(Rest2, 0, 0, F1,
			    cons(NewFValue, F2, TrUserData), TrUserData).


skip_varint_Spec(<<1:1, _:7, Rest/binary>>, Z1, Z2, F1,
		 F2, TrUserData) ->
    skip_varint_Spec(Rest, Z1, Z2, F1, F2, TrUserData);
skip_varint_Spec(<<0:1, _:7, Rest/binary>>, Z1, Z2, F1,
		 F2, TrUserData) ->
    dfp_read_field_def_Spec(Rest, Z1, Z2, F1, F2,
			    TrUserData).


skip_length_delimited_Spec(<<1:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, TrUserData)
    when N < 57 ->
    skip_length_delimited_Spec(Rest, N + 7, X bsl N + Acc,
			       F1, F2, TrUserData);
skip_length_delimited_Spec(<<0:1, X:7, Rest/binary>>, N,
			   Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    dfp_read_field_def_Spec(Rest2, 0, 0, F1, F2,
			    TrUserData).


skip_32_Spec(<<_:32, Rest/binary>>, Z1, Z2, F1, F2,
	     TrUserData) ->
    dfp_read_field_def_Spec(Rest, Z1, Z2, F1, F2,
			    TrUserData).


skip_64_Spec(<<_:64, Rest/binary>>, Z1, Z2, F1, F2,
	     TrUserData) ->
    dfp_read_field_def_Spec(Rest, Z1, Z2, F1, F2,
			    TrUserData).



'd_msg_map<string,ErlangTerm>'(Bin, TrUserData) ->
    'dfp_read_field_def_map<string,ErlangTerm>'(Bin, 0, 0,
						id(undefined, TrUserData),
						id(undefined, TrUserData),
						TrUserData).

'dfp_read_field_def_map<string,ErlangTerm>'(<<10,
					      Rest/binary>>,
					    Z1, Z2, F1, F2, TrUserData) ->
    'd_field_map<string,ErlangTerm>_key'(Rest, Z1, Z2, F1,
					 F2, TrUserData);
'dfp_read_field_def_map<string,ErlangTerm>'(<<18,
					      Rest/binary>>,
					    Z1, Z2, F1, F2, TrUserData) ->
    'd_field_map<string,ErlangTerm>_value'(Rest, Z1, Z2, F1,
					   F2, TrUserData);
'dfp_read_field_def_map<string,ErlangTerm>'(<<>>, 0, 0,
					    F1, F2, _) ->
    #'map<string,ErlangTerm>'{key = F1, value = F2};
'dfp_read_field_def_map<string,ErlangTerm>'(Other, Z1,
					    Z2, F1, F2, TrUserData) ->
    'dg_read_field_def_map<string,ErlangTerm>'(Other, Z1,
					       Z2, F1, F2, TrUserData).

'dg_read_field_def_map<string,ErlangTerm>'(<<1:1, X:7,
					     Rest/binary>>,
					   N, Acc, F1, F2, TrUserData)
    when N < 32 - 7 ->
    'dg_read_field_def_map<string,ErlangTerm>'(Rest, N + 7,
					       X bsl N + Acc, F1, F2,
					       TrUserData);
'dg_read_field_def_map<string,ErlangTerm>'(<<0:1, X:7,
					     Rest/binary>>,
					   N, Acc, F1, F2, TrUserData) ->
    Key = X bsl N + Acc,
    case Key of
      10 ->
	  'd_field_map<string,ErlangTerm>_key'(Rest, 0, 0, F1, F2,
					       TrUserData);
      18 ->
	  'd_field_map<string,ErlangTerm>_value'(Rest, 0, 0, F1,
						 F2, TrUserData);
      _ ->
	  case Key band 7 of
	    0 ->
		'skip_varint_map<string,ErlangTerm>'(Rest, 0, 0, F1, F2,
						     TrUserData);
	    1 ->
		'skip_64_map<string,ErlangTerm>'(Rest, 0, 0, F1, F2,
						 TrUserData);
	    2 ->
		'skip_length_delimited_map<string,ErlangTerm>'(Rest, 0,
							       0, F1, F2,
							       TrUserData);
	    5 ->
		'skip_32_map<string,ErlangTerm>'(Rest, 0, 0, F1, F2,
						 TrUserData)
	  end
    end;
'dg_read_field_def_map<string,ErlangTerm>'(<<>>, 0, 0,
					   F1, F2, _) ->
    #'map<string,ErlangTerm>'{key = F1, value = F2}.

'd_field_map<string,ErlangTerm>_key'(<<1:1, X:7,
				       Rest/binary>>,
				     N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_map<string,ErlangTerm>_key'(Rest, N + 7,
					 X bsl N + Acc, F1, F2, TrUserData);
'd_field_map<string,ErlangTerm>_key'(<<0:1, X:7,
				       Rest/binary>>,
				     N, Acc, _, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Utf8:Len/binary, Rest2/binary>> = Rest,
    NewFValue = unicode:characters_to_list(Utf8, unicode),
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest2, 0, 0,
						NewFValue, F2, TrUserData).


'd_field_map<string,ErlangTerm>_value'(<<1:1, X:7,
					 Rest/binary>>,
				       N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'd_field_map<string,ErlangTerm>_value'(Rest, N + 7,
					   X bsl N + Acc, F1, F2, TrUserData);
'd_field_map<string,ErlangTerm>_value'(<<0:1, X:7,
					 Rest/binary>>,
				       N, Acc, F1, F2, TrUserData) ->
    Len = X bsl N + Acc,
    <<Bs:Len/binary, Rest2/binary>> = Rest,
    NewFValue = id(d_msg_ErlangTerm(Bs, TrUserData),
		   TrUserData),
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest2, 0, 0,
						F1,
						if F2 == undefined -> NewFValue;
						   true ->
						       merge_msg_ErlangTerm(F2,
									    NewFValue,
									    TrUserData)
						end,
						TrUserData).


'skip_varint_map<string,ErlangTerm>'(<<1:1, _:7,
				       Rest/binary>>,
				     Z1, Z2, F1, F2, TrUserData) ->
    'skip_varint_map<string,ErlangTerm>'(Rest, Z1, Z2, F1,
					 F2, TrUserData);
'skip_varint_map<string,ErlangTerm>'(<<0:1, _:7,
				       Rest/binary>>,
				     Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest, Z1,
						Z2, F1, F2, TrUserData).


'skip_length_delimited_map<string,ErlangTerm>'(<<1:1,
						 X:7, Rest/binary>>,
					       N, Acc, F1, F2, TrUserData)
    when N < 57 ->
    'skip_length_delimited_map<string,ErlangTerm>'(Rest,
						   N + 7, X bsl N + Acc, F1, F2,
						   TrUserData);
'skip_length_delimited_map<string,ErlangTerm>'(<<0:1,
						 X:7, Rest/binary>>,
					       N, Acc, F1, F2, TrUserData) ->
    Length = X bsl N + Acc,
    <<_:Length/binary, Rest2/binary>> = Rest,
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest2, 0, 0,
						F1, F2, TrUserData).


'skip_32_map<string,ErlangTerm>'(<<_:32, Rest/binary>>,
				 Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest, Z1,
						Z2, F1, F2, TrUserData).


'skip_64_map<string,ErlangTerm>'(<<_:64, Rest/binary>>,
				 Z1, Z2, F1, F2, TrUserData) ->
    'dfp_read_field_def_map<string,ErlangTerm>'(Rest, Z1,
						Z2, F1, F2, TrUserData).



'd_enum_LogEntry.Type'(0) -> 'OP_PARAMS';
'd_enum_LogEntry.Type'(1) -> 'OP_SPEC';
'd_enum_LogEntry.Type'(2) -> 'OP_LAMBDA';
'd_enum_LogEntry.Type'(3) -> 'OP_EVALUATED_CLOSURE';
'd_enum_LogEntry.Type'(4) ->
    'OP_FRESH_LAMBDA_WITH_ARITY';
'd_enum_LogEntry.Type'(5) -> 'OP_NOT_LAMBDA_WITH_ARITY';
'd_enum_LogEntry.Type'(6) -> 'OP_GUARD_TRUE';
'd_enum_LogEntry.Type'(7) -> 'OP_GUARD_FALSE';
'd_enum_LogEntry.Type'(8) -> 'OP_MATCH_EQUAL_TRUE';
'd_enum_LogEntry.Type'(9) -> 'OP_MATCH_EQUAL_FALSE';
'd_enum_LogEntry.Type'(10) -> 'OP_TUPLE_SZ';
'd_enum_LogEntry.Type'(11) -> 'OP_TUPLE_NOT_SZ';
'd_enum_LogEntry.Type'(12) -> 'OP_TUPLE_NOT_TPL';
'd_enum_LogEntry.Type'(13) -> 'OP_LIST_NON_EMPTY';
'd_enum_LogEntry.Type'(14) -> 'OP_LIST_EMPTY';
'd_enum_LogEntry.Type'(15) -> 'OP_LIST_NOT_LST';
'd_enum_LogEntry.Type'(16) -> 'OP_SPAWN';
'd_enum_LogEntry.Type'(17) -> 'OP_SPAWNED';
'd_enum_LogEntry.Type'(18) -> 'OP_MSG_SEND';
'd_enum_LogEntry.Type'(19) -> 'OP_MSG_RECEIVE';
'd_enum_LogEntry.Type'(20) -> 'OP_MSG_CONSUME';
'd_enum_LogEntry.Type'(21) -> 'OP_UNFOLD_TUPLE';
'd_enum_LogEntry.Type'(22) -> 'OP_UNFOLD_LIST';
'd_enum_LogEntry.Type'(23) -> 'OP_BOGUS';
'd_enum_LogEntry.Type'(24) -> 'OP_FLOAT';
'd_enum_LogEntry.Type'(25) -> 'OP_LIST_TO_TUPLE';
'd_enum_LogEntry.Type'(26) -> 'OP_TUPLE_TO_LIST';
'd_enum_LogEntry.Type'(27) -> 'OP_IS_INTEGER';
'd_enum_LogEntry.Type'(28) -> 'OP_IS_ATOM';
'd_enum_LogEntry.Type'(29) -> 'OP_IS_FLOAT';
'd_enum_LogEntry.Type'(30) -> 'OP_IS_LIST';
'd_enum_LogEntry.Type'(31) -> 'OP_IS_TUPLE';
'd_enum_LogEntry.Type'(32) -> 'OP_IS_BOOLEAN';
'd_enum_LogEntry.Type'(33) -> 'OP_IS_NUMBER';
'd_enum_LogEntry.Type'(34) -> 'OP_IS_BITSTRING';
'd_enum_LogEntry.Type'(35) -> 'OP_IS_FUN';
'd_enum_LogEntry.Type'(36) -> 'OP_IS_FUN_WITH_ARITY';
'd_enum_LogEntry.Type'(37) -> 'OP_PLUS';
'd_enum_LogEntry.Type'(38) -> 'OP_MINUS';
'd_enum_LogEntry.Type'(39) -> 'OP_TIMES';
'd_enum_LogEntry.Type'(40) -> 'OP_RDIV';
'd_enum_LogEntry.Type'(41) -> 'OP_IDIV_NAT';
'd_enum_LogEntry.Type'(42) -> 'OP_REM_NAT';
'd_enum_LogEntry.Type'(43) -> 'OP_UNARY';
'd_enum_LogEntry.Type'(44) -> 'OP_POW';
'd_enum_LogEntry.Type'(45) -> 'OP_TRUNC';
'd_enum_LogEntry.Type'(46) -> 'OP_ATOM_NIL';
'd_enum_LogEntry.Type'(47) -> 'OP_ATOM_HEAD';
'd_enum_LogEntry.Type'(48) -> 'OP_ATOM_TAIL';
'd_enum_LogEntry.Type'(49) -> 'OP_HD';
'd_enum_LogEntry.Type'(50) -> 'OP_TL';
'd_enum_LogEntry.Type'(51) -> 'OP_CONS';
'd_enum_LogEntry.Type'(52) -> 'OP_TCONS';
'd_enum_LogEntry.Type'(53) -> 'OP_EQUAL';
'd_enum_LogEntry.Type'(54) -> 'OP_UNEQUAL';
'd_enum_LogEntry.Type'(55) -> 'OP_LT_INT';
'd_enum_LogEntry.Type'(56) -> 'OP_LT_FLOAT';
'd_enum_LogEntry.Type'(57) -> 'OP_MAKE_BITSTR';
'd_enum_LogEntry.Type'(58) -> 'OP_EMPTY_BITSTR';
'd_enum_LogEntry.Type'(59) -> 'OP_NONEMPTY_BITSTR';
'd_enum_LogEntry.Type'(60) -> 'OP_CONCAT_SEGS';
'd_enum_LogEntry.Type'(61) -> 'OP_BITMATCH_CONST_TRUE';
'd_enum_LogEntry.Type'(62) -> 'OP_BITMATCH_CONST_FALSE';
'd_enum_LogEntry.Type'(63) -> 'OP_BITMATCH_VAR_TRUE';
'd_enum_LogEntry.Type'(64) -> 'OP_BITMATCH_VAR_FALSE';
'd_enum_LogEntry.Type'(65) -> 'OP_BAND';
'd_enum_LogEntry.Type'(66) -> 'OP_BXOR';
'd_enum_LogEntry.Type'(67) -> 'OP_BOR';
'd_enum_LogEntry.Type'(V) -> V.

'd_enum_ErlangTerm.Type'(0) -> 'INTEGER';
'd_enum_ErlangTerm.Type'(1) -> 'FLOAT';
'd_enum_ErlangTerm.Type'(2) -> 'ATOM';
'd_enum_ErlangTerm.Type'(3) -> 'TUPLE';
'd_enum_ErlangTerm.Type'(4) -> 'LIST';
'd_enum_ErlangTerm.Type'(5) -> 'IMPROPER_LIST';
'd_enum_ErlangTerm.Type'(6) -> 'PID';
'd_enum_ErlangTerm.Type'(7) -> 'REFERENCE';
'd_enum_ErlangTerm.Type'(8) -> 'BITSTRING';
'd_enum_ErlangTerm.Type'(9) -> 'MAP';
'd_enum_ErlangTerm.Type'(10) -> 'FUN';
'd_enum_ErlangTerm.Type'(11) -> 'SYMBOLIC_VARIABLE';
'd_enum_ErlangTerm.Type'(12) -> 'SUBTERM';
'd_enum_ErlangTerm.Type'(13) -> 'ANY';
'd_enum_ErlangTerm.Type'(V) -> V.

'd_enum_Spec.ErlType'(0) -> 'ANY';
'd_enum_Spec.ErlType'(1) -> 'ATOM';
'd_enum_Spec.ErlType'(2) -> 'ATOM_LITERAL';
'd_enum_Spec.ErlType'(3) -> 'FLOAT';
'd_enum_Spec.ErlType'(4) -> 'INTEGER';
'd_enum_Spec.ErlType'(5) -> 'INTEGER_LITERAL';
'd_enum_Spec.ErlType'(6) -> 'LIST';
'd_enum_Spec.ErlType'(7) -> 'NONEMPTY_LIST';
'd_enum_Spec.ErlType'(8) -> 'NIL';
'd_enum_Spec.ErlType'(9) -> 'BITSTRING';
'd_enum_Spec.ErlType'(10) -> 'TUPLE';
'd_enum_Spec.ErlType'(11) -> 'TUPLEDET';
'd_enum_Spec.ErlType'(12) -> 'UNION';
'd_enum_Spec.ErlType'(13) -> 'RANGE';
'd_enum_Spec.ErlType'(14) -> 'FUN';
'd_enum_Spec.ErlType'(15) -> 'CONS';
'd_enum_Spec.ErlType'(16) -> 'NTUPLE';
'd_enum_Spec.ErlType'(17) -> 'USERDEF';
'd_enum_Spec.ErlType'(V) -> V.



merge_msgs(Prev, New) -> merge_msgs(Prev, New, []).

merge_msgs(Prev, New, Opts)
    when element(1, Prev) =:= element(1, New) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case Prev of
      #'LogEntry'{} ->
	  merge_msg_LogEntry(Prev, New, TrUserData);
      #'ErlangTerm.MapEntry'{} ->
	  'merge_msg_ErlangTerm.MapEntry'(Prev, New, TrUserData);
      #'ErlangTerm.FunEntry'{} ->
	  'merge_msg_ErlangTerm.FunEntry'(Prev, New, TrUserData);
      #'ErlangTerm'{} ->
	  merge_msg_ErlangTerm(Prev, New, TrUserData);
      #'Spec.TypeDef'{} ->
	  'merge_msg_Spec.TypeDef'(Prev, New, TrUserData);
      #'Spec.RangeBounds'{} ->
	  'merge_msg_Spec.RangeBounds'(Prev, New, TrUserData);
      #'Spec.SegmentSize'{} ->
	  'merge_msg_Spec.SegmentSize'(Prev, New, TrUserData);
      #'Spec.FunSig'{} ->
	  'merge_msg_Spec.FunSig'(Prev, New, TrUserData);
      #'Spec.FunDet'{} ->
	  'merge_msg_Spec.FunDet'(Prev, New, TrUserData);
      #'Spec.Type'{} ->
	  'merge_msg_Spec.Type'(Prev, New, TrUserData);
      #'Spec.TypeList'{} ->
	  'merge_msg_Spec.TypeList'(Prev, New, TrUserData);
      #'Spec'{} -> merge_msg_Spec(Prev, New, TrUserData)
    end.

merge_msg_LogEntry(#'LogEntry'{type = PFtype,
			       arguments = PFarguments,
			       is_constraint = PFis_constraint, tag = PFtag,
			       spec = PFspec},
		   #'LogEntry'{type = NFtype, arguments = NFarguments,
			       is_constraint = NFis_constraint, tag = NFtag,
			       spec = NFspec},
		   TrUserData) ->
    #'LogEntry'{type =
		    if NFtype =:= undefined -> PFtype;
		       true -> NFtype
		    end,
		arguments =
		    'erlang_++'(PFarguments, NFarguments, TrUserData),
		is_constraint =
		    if NFis_constraint =:= undefined -> PFis_constraint;
		       true -> NFis_constraint
		    end,
		tag =
		    if NFtag =:= undefined -> PFtag;
		       true -> NFtag
		    end,
		spec =
		    if PFspec /= undefined, NFspec /= undefined ->
			   merge_msg_Spec(PFspec, NFspec, TrUserData);
		       PFspec == undefined -> NFspec;
		       NFspec == undefined -> PFspec
		    end}.

'merge_msg_ErlangTerm.MapEntry'(#'ErlangTerm.MapEntry'{key
							   = PFkey,
						       value = PFvalue},
				#'ErlangTerm.MapEntry'{key = NFkey,
						       value = NFvalue},
				TrUserData) ->
    #'ErlangTerm.MapEntry'{key =
			       if PFkey /= undefined, NFkey /= undefined ->
				      merge_msg_ErlangTerm(PFkey, NFkey,
							   TrUserData);
				  PFkey == undefined -> NFkey;
				  NFkey == undefined -> PFkey
			       end,
			   value =
			       if PFvalue /= undefined, NFvalue /= undefined ->
				      merge_msg_ErlangTerm(PFvalue, NFvalue,
							   TrUserData);
				  PFvalue == undefined -> NFvalue;
				  NFvalue == undefined -> PFvalue
			       end}.

'merge_msg_ErlangTerm.FunEntry'(#'ErlangTerm.FunEntry'{arguments
							   = PFarguments,
						       value = PFvalue},
				#'ErlangTerm.FunEntry'{arguments = NFarguments,
						       value = NFvalue},
				TrUserData) ->
    #'ErlangTerm.FunEntry'{arguments =
			       'erlang_++'(PFarguments, NFarguments,
					   TrUserData),
			   value =
			       if PFvalue /= undefined, NFvalue /= undefined ->
				      merge_msg_ErlangTerm(PFvalue, NFvalue,
							   TrUserData);
				  PFvalue == undefined -> NFvalue;
				  NFvalue == undefined -> PFvalue
			       end}.

merge_msg_ErlangTerm(#'ErlangTerm'{type = PFtype,
				   value = PFvalue, subterms = PFsubterms,
				   shared = PFshared,
				   improper_list_nil = PFimproper_list_nil,
				   atom_chars = PFatom_chars, bits = PFbits,
				   map_entries = PFmap_entries,
				   points = PFpoints, otherwise = PFotherwise,
				   arity = PFarity},
		     #'ErlangTerm'{type = NFtype, value = NFvalue,
				   subterms = NFsubterms, shared = NFshared,
				   improper_list_nil = NFimproper_list_nil,
				   atom_chars = NFatom_chars, bits = NFbits,
				   map_entries = NFmap_entries,
				   points = NFpoints, otherwise = NFotherwise,
				   arity = NFarity},
		     TrUserData) ->
    #'ErlangTerm'{type =
		      if NFtype =:= undefined -> PFtype;
			 true -> NFtype
		      end,
		  value =
		      if NFvalue =:= undefined -> PFvalue;
			 true -> NFvalue
		      end,
		  subterms =
		      'erlang_++'(PFsubterms, NFsubterms, TrUserData),
		  shared =
		      'tr_merge_ErlangTerm.shared'(PFshared, NFshared,
						   TrUserData),
		  improper_list_nil =
		      if PFimproper_list_nil /= undefined,
			 NFimproper_list_nil /= undefined ->
			     merge_msg_ErlangTerm(PFimproper_list_nil,
						  NFimproper_list_nil,
						  TrUserData);
			 PFimproper_list_nil == undefined ->
			     NFimproper_list_nil;
			 NFimproper_list_nil == undefined -> PFimproper_list_nil
		      end,
		  atom_chars =
		      'erlang_++'(PFatom_chars, NFatom_chars, TrUserData),
		  bits = 'erlang_++'(PFbits, NFbits, TrUserData),
		  map_entries =
		      'erlang_++'(PFmap_entries, NFmap_entries, TrUserData),
		  points = 'erlang_++'(PFpoints, NFpoints, TrUserData),
		  otherwise =
		      if PFotherwise /= undefined, NFotherwise /= undefined ->
			     merge_msg_ErlangTerm(PFotherwise, NFotherwise,
						  TrUserData);
			 PFotherwise == undefined -> NFotherwise;
			 NFotherwise == undefined -> PFotherwise
		      end,
		  arity =
		      if NFarity =:= undefined -> PFarity;
			 true -> NFarity
		      end}.

'merge_msg_Spec.TypeDef'(#'Spec.TypeDef'{name = PFname,
					 definition = PFdefinition},
			 #'Spec.TypeDef'{name = NFname,
					 definition = NFdefinition},
			 TrUserData) ->
    #'Spec.TypeDef'{name =
			if NFname =:= undefined -> PFname;
			   true -> NFname
			end,
		    definition =
			if PFdefinition /= undefined,
			   NFdefinition /= undefined ->
			       'merge_msg_Spec.Type'(PFdefinition, NFdefinition,
						     TrUserData);
			   PFdefinition == undefined -> NFdefinition;
			   NFdefinition == undefined -> PFdefinition
			end}.

'merge_msg_Spec.RangeBounds'(#'Spec.RangeBounds'{lower_bound
						     = PFlower_bound,
						 upper_bound = PFupper_bound},
			     #'Spec.RangeBounds'{lower_bound = NFlower_bound,
						 upper_bound = NFupper_bound},
			     _) ->
    #'Spec.RangeBounds'{lower_bound =
			    if NFlower_bound =:= undefined -> PFlower_bound;
			       true -> NFlower_bound
			    end,
			upper_bound =
			    if NFupper_bound =:= undefined -> PFupper_bound;
			       true -> NFupper_bound
			    end}.

'merge_msg_Spec.SegmentSize'(#'Spec.SegmentSize'{m =
						     PFm,
						 n = PFn},
			     #'Spec.SegmentSize'{m = NFm, n = NFn}, _) ->
    #'Spec.SegmentSize'{m =
			    if NFm =:= undefined -> PFm;
			       true -> NFm
			    end,
			n =
			    if NFn =:= undefined -> PFn;
			       true -> NFn
			    end}.

'merge_msg_Spec.FunSig'(#'Spec.FunSig'{signature =
					   PFsignature},
			#'Spec.FunSig'{signature = NFsignature}, TrUserData) ->
    #'Spec.FunSig'{signature =
		       case {PFsignature, NFsignature} of
			 {{complete, OPFsignature}, {complete, ONFsignature}} ->
			     {complete,
			      'merge_msg_Spec.FunDet'(OPFsignature,
						      ONFsignature,
						      TrUserData)};
			 {{just_return, OPFsignature},
			  {just_return, ONFsignature}} ->
			     {just_return,
			      'merge_msg_Spec.Type'(OPFsignature, ONFsignature,
						    TrUserData)};
			 {_, undefined} -> PFsignature;
			 _ -> NFsignature
		       end}.

'merge_msg_Spec.FunDet'(#'Spec.FunDet'{parameters =
					   PFparameters,
				       return_value = PFreturn_value},
			#'Spec.FunDet'{parameters = NFparameters,
				       return_value = NFreturn_value},
			TrUserData) ->
    #'Spec.FunDet'{parameters =
		       'erlang_++'(PFparameters, NFparameters, TrUserData),
		   return_value =
		       if PFreturn_value /= undefined,
			  NFreturn_value /= undefined ->
			      'merge_msg_Spec.Type'(PFreturn_value,
						    NFreturn_value, TrUserData);
			  PFreturn_value == undefined -> NFreturn_value;
			  NFreturn_value == undefined -> PFreturn_value
		       end}.

'merge_msg_Spec.Type'(#'Spec.Type'{type = PFtype,
				   arg = PFarg},
		      #'Spec.Type'{type = NFtype, arg = NFarg}, TrUserData) ->
    #'Spec.Type'{type =
		     if NFtype =:= undefined -> PFtype;
			true -> NFtype
		     end,
		 arg =
		     case {PFarg, NFarg} of
		       {{literal, OPFarg}, {literal, ONFarg}} ->
			   {literal,
			    merge_msg_ErlangTerm(OPFarg, ONFarg, TrUserData)};
		       {{range_bounds, OPFarg}, {range_bounds, ONFarg}} ->
			   {range_bounds,
			    'merge_msg_Spec.RangeBounds'(OPFarg, ONFarg,
							 TrUserData)};
		       {{segment_size, OPFarg}, {segment_size, ONFarg}} ->
			   {segment_size,
			    'merge_msg_Spec.SegmentSize'(OPFarg, ONFarg,
							 TrUserData)};
		       {{inner_type, OPFarg}, {inner_type, ONFarg}} ->
			   {inner_type,
			    'merge_msg_Spec.Type'(OPFarg, ONFarg, TrUserData)};
		       {{inner_types, OPFarg}, {inner_types, ONFarg}} ->
			   {inner_types,
			    'merge_msg_Spec.TypeList'(OPFarg, ONFarg,
						      TrUserData)};
		       {{'fun', OPFarg}, {'fun', ONFarg}} ->
			   {'fun',
			    'merge_msg_Spec.FunSig'(OPFarg, ONFarg,
						    TrUserData)};
		       {_, undefined} -> PFarg;
		       _ -> NFarg
		     end}.

'merge_msg_Spec.TypeList'(#'Spec.TypeList'{types =
					       PFtypes},
			  #'Spec.TypeList'{types = NFtypes}, TrUserData) ->
    #'Spec.TypeList'{types =
			 'erlang_++'(PFtypes, NFtypes, TrUserData)}.

merge_msg_Spec(#'Spec'{clauses = PFclauses,
		       typedefs = PFtypedefs},
	       #'Spec'{clauses = NFclauses, typedefs = NFtypedefs},
	       TrUserData) ->
    #'Spec'{clauses =
		'erlang_++'(PFclauses, NFclauses, TrUserData),
	    typedefs =
		'erlang_++'(PFtypedefs, NFtypedefs, TrUserData)}.



verify_msg(Msg) -> verify_msg(Msg, []).

verify_msg(Msg, Opts) ->
    TrUserData = proplists:get_value(user_data, Opts),
    case Msg of
      #'LogEntry'{} ->
	  v_msg_LogEntry(Msg, ['LogEntry'], TrUserData);
      #'ErlangTerm.MapEntry'{} ->
	  'v_msg_ErlangTerm.MapEntry'(Msg,
				      ['ErlangTerm.MapEntry'], TrUserData);
      #'ErlangTerm.FunEntry'{} ->
	  'v_msg_ErlangTerm.FunEntry'(Msg,
				      ['ErlangTerm.FunEntry'], TrUserData);
      #'ErlangTerm'{} ->
	  v_msg_ErlangTerm(Msg, ['ErlangTerm'], TrUserData);
      #'Spec.TypeDef'{} ->
	  'v_msg_Spec.TypeDef'(Msg, ['Spec.TypeDef'], TrUserData);
      #'Spec.RangeBounds'{} ->
	  'v_msg_Spec.RangeBounds'(Msg, ['Spec.RangeBounds'],
				   TrUserData);
      #'Spec.SegmentSize'{} ->
	  'v_msg_Spec.SegmentSize'(Msg, ['Spec.SegmentSize'],
				   TrUserData);
      #'Spec.FunSig'{} ->
	  'v_msg_Spec.FunSig'(Msg, ['Spec.FunSig'], TrUserData);
      #'Spec.FunDet'{} ->
	  'v_msg_Spec.FunDet'(Msg, ['Spec.FunDet'], TrUserData);
      #'Spec.Type'{} ->
	  'v_msg_Spec.Type'(Msg, ['Spec.Type'], TrUserData);
      #'Spec.TypeList'{} ->
	  'v_msg_Spec.TypeList'(Msg, ['Spec.TypeList'],
				TrUserData);
      #'Spec'{} -> v_msg_Spec(Msg, ['Spec'], TrUserData);
      _ -> mk_type_error(not_a_known_message, Msg, [])
    end.


v_msg_LogEntry(#'LogEntry'{type = F1, arguments = F2,
			   is_constraint = F3, tag = F4, spec = F5},
	       Path, TrUserData) ->
    if F1 == undefined -> ok;
       true -> 'v_enum_LogEntry.Type'(F1, [type | Path])
    end,
    if is_list(F2) ->
	   _ = [v_msg_ErlangTerm(Elem, [arguments | Path],
				 TrUserData)
		|| Elem <- F2],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'ErlangTerm'}},
			 F2, Path)
    end,
    if F3 == undefined -> ok;
       true -> v_type_bool(F3, [is_constraint | Path])
    end,
    if F4 == undefined -> ok;
       true -> v_type_uint64(F4, [tag | Path])
    end,
    if F5 == undefined -> ok;
       true -> v_msg_Spec(F5, [spec | Path], TrUserData)
    end,
    ok.

'v_msg_ErlangTerm.MapEntry'(#'ErlangTerm.MapEntry'{key =
						       F1,
						   value = F2},
			    Path, TrUserData) ->
    if F1 == undefined -> ok;
       true -> v_msg_ErlangTerm(F1, [key | Path], TrUserData)
    end,
    if F2 == undefined -> ok;
       true -> v_msg_ErlangTerm(F2, [value | Path], TrUserData)
    end,
    ok;
'v_msg_ErlangTerm.MapEntry'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'ErlangTerm.MapEntry'}, X,
		  Path).

'v_msg_ErlangTerm.FunEntry'(#'ErlangTerm.FunEntry'{arguments
						       = F1,
						   value = F2},
			    Path, TrUserData) ->
    if is_list(F1) ->
	   _ = [v_msg_ErlangTerm(Elem, [arguments | Path],
				 TrUserData)
		|| Elem <- F1],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'ErlangTerm'}},
			 F1, Path)
    end,
    if F2 == undefined -> ok;
       true -> v_msg_ErlangTerm(F2, [value | Path], TrUserData)
    end,
    ok;
'v_msg_ErlangTerm.FunEntry'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'ErlangTerm.FunEntry'}, X,
		  Path).

v_msg_ErlangTerm(#'ErlangTerm'{type = F1, value = F2,
			       subterms = F3, shared = F4,
			       improper_list_nil = F5, atom_chars = F6,
			       bits = F7, map_entries = F8, points = F9,
			       otherwise = F10, arity = F11},
		 Path, TrUserData) ->
    if F1 == undefined -> ok;
       true -> 'v_enum_ErlangTerm.Type'(F1, [type | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_string(F2, [value | Path])
    end,
    if is_list(F3) ->
	   _ = [v_msg_ErlangTerm(Elem, [subterms | Path],
				 TrUserData)
		|| Elem <- F3],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'ErlangTerm'}},
			 F3, Path)
    end,
    'v_map<string,ErlangTerm>'(F4, [shared | Path],
			       TrUserData),
    if F5 == undefined -> ok;
       true ->
	   v_msg_ErlangTerm(F5, [improper_list_nil | Path],
			    TrUserData)
    end,
    if is_list(F6) ->
	   _ = [v_type_int32(Elem, [atom_chars | Path])
		|| Elem <- F6],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, int32}, F6, Path)
    end,
    if is_list(F7) ->
	   _ = [v_type_bool(Elem, [bits | Path]) || Elem <- F7],
	   ok;
       true -> mk_type_error({invalid_list_of, bool}, F7, Path)
    end,
    if is_list(F8) ->
	   _ = ['v_msg_ErlangTerm.MapEntry'(Elem,
					    [map_entries | Path], TrUserData)
		|| Elem <- F8],
	   ok;
       true ->
	   mk_type_error({invalid_list_of,
			  {msg, 'ErlangTerm.MapEntry'}},
			 F8, Path)
    end,
    if is_list(F9) ->
	   _ = ['v_msg_ErlangTerm.FunEntry'(Elem, [points | Path],
					    TrUserData)
		|| Elem <- F9],
	   ok;
       true ->
	   mk_type_error({invalid_list_of,
			  {msg, 'ErlangTerm.FunEntry'}},
			 F9, Path)
    end,
    if F10 == undefined -> ok;
       true ->
	   v_msg_ErlangTerm(F10, [otherwise | Path], TrUserData)
    end,
    if F11 == undefined -> ok;
       true -> v_type_int32(F11, [arity | Path])
    end,
    ok;
v_msg_ErlangTerm(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'ErlangTerm'}, X, Path).

'v_msg_Spec.TypeDef'(#'Spec.TypeDef'{name = F1,
				     definition = F2},
		     Path, TrUserData) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [name | Path])
    end,
    if F2 == undefined -> ok;
       true ->
	   'v_msg_Spec.Type'(F2, [definition | Path], TrUserData)
    end,
    ok;
'v_msg_Spec.TypeDef'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.TypeDef'}, X, Path).

'v_msg_Spec.RangeBounds'(#'Spec.RangeBounds'{lower_bound
						 = F1,
					     upper_bound = F2},
			 Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [lower_bound | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_string(F2, [upper_bound | Path])
    end,
    ok;
'v_msg_Spec.RangeBounds'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.RangeBounds'}, X,
		  Path).

'v_msg_Spec.SegmentSize'(#'Spec.SegmentSize'{m = F1,
					     n = F2},
			 Path, _) ->
    if F1 == undefined -> ok;
       true -> v_type_string(F1, [m | Path])
    end,
    if F2 == undefined -> ok;
       true -> v_type_string(F2, [n | Path])
    end,
    ok;
'v_msg_Spec.SegmentSize'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.SegmentSize'}, X,
		  Path).

'v_msg_Spec.FunSig'(#'Spec.FunSig'{signature = F1},
		    Path, TrUserData) ->
    case F1 of
      undefined -> ok;
      {complete, OF1} ->
	  'v_msg_Spec.FunDet'(OF1, [complete, signature | Path],
			      TrUserData);
      {just_return, OF1} ->
	  'v_msg_Spec.Type'(OF1, [just_return, signature | Path],
			    TrUserData);
      _ ->
	  mk_type_error(invalid_oneof, F1, [signature | Path])
    end,
    ok;
'v_msg_Spec.FunSig'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.FunSig'}, X, Path).

'v_msg_Spec.FunDet'(#'Spec.FunDet'{parameters = F1,
				   return_value = F2},
		    Path, TrUserData) ->
    if is_list(F1) ->
	   _ = ['v_msg_Spec.Type'(Elem, [parameters | Path],
				  TrUserData)
		|| Elem <- F1],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'Spec.Type'}}, F1,
			 Path)
    end,
    if F2 == undefined -> ok;
       true ->
	   'v_msg_Spec.Type'(F2, [return_value | Path], TrUserData)
    end,
    ok;
'v_msg_Spec.FunDet'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.FunDet'}, X, Path).

'v_msg_Spec.Type'(#'Spec.Type'{type = F1, arg = F2},
		  Path, TrUserData) ->
    if F1 == undefined -> ok;
       true -> 'v_enum_Spec.ErlType'(F1, [type | Path])
    end,
    case F2 of
      undefined -> ok;
      {literal, OF2} ->
	  v_msg_ErlangTerm(OF2, [literal, arg | Path],
			   TrUserData);
      {range_bounds, OF2} ->
	  'v_msg_Spec.RangeBounds'(OF2,
				   [range_bounds, arg | Path], TrUserData);
      {segment_size, OF2} ->
	  'v_msg_Spec.SegmentSize'(OF2,
				   [segment_size, arg | Path], TrUserData);
      {inner_type, OF2} ->
	  'v_msg_Spec.Type'(OF2, [inner_type, arg | Path],
			    TrUserData);
      {inner_types, OF2} ->
	  'v_msg_Spec.TypeList'(OF2, [inner_types, arg | Path],
				TrUserData);
      {'fun', OF2} ->
	  'v_msg_Spec.FunSig'(OF2, ['fun', arg | Path],
			      TrUserData);
      {ntuple_size, OF2} ->
	  v_type_uint32(OF2, [ntuple_size, arg | Path]);
      {type_name, OF2} ->
	  v_type_string(OF2, [type_name, arg | Path]);
      _ -> mk_type_error(invalid_oneof, F2, [arg | Path])
    end,
    ok;
'v_msg_Spec.Type'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.Type'}, X, Path).

'v_msg_Spec.TypeList'(#'Spec.TypeList'{types = F1},
		      Path, TrUserData) ->
    if is_list(F1) ->
	   _ = ['v_msg_Spec.Type'(Elem, [types | Path], TrUserData)
		|| Elem <- F1],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'Spec.Type'}}, F1,
			 Path)
    end,
    ok;
'v_msg_Spec.TypeList'(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec.TypeList'}, X, Path).

v_msg_Spec(#'Spec'{clauses = F1, typedefs = F2}, Path,
	   TrUserData) ->
    if is_list(F1) ->
	   _ = ['v_msg_Spec.FunSig'(Elem, [clauses | Path],
				    TrUserData)
		|| Elem <- F1],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'Spec.FunSig'}},
			 F1, Path)
    end,
    if is_list(F2) ->
	   _ = ['v_msg_Spec.TypeDef'(Elem, [typedefs | Path],
				     TrUserData)
		|| Elem <- F2],
	   ok;
       true ->
	   mk_type_error({invalid_list_of, {msg, 'Spec.TypeDef'}},
			 F2, Path)
    end,
    ok;
v_msg_Spec(X, Path, _TrUserData) ->
    mk_type_error({expected_msg, 'Spec'}, X, Path).

'v_enum_LogEntry.Type'('OP_PARAMS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_SPEC', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LAMBDA', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_EVALUATED_CLOSURE', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_FRESH_LAMBDA_WITH_ARITY',
		       _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_NOT_LAMBDA_WITH_ARITY',
		       _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_GUARD_TRUE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_GUARD_FALSE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MATCH_EQUAL_TRUE', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_MATCH_EQUAL_FALSE', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_TUPLE_SZ', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TUPLE_NOT_SZ', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TUPLE_NOT_TPL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LIST_NON_EMPTY', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_LIST_EMPTY', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LIST_NOT_LST', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_SPAWN', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_SPAWNED', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MSG_SEND', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MSG_RECEIVE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MSG_CONSUME', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_UNFOLD_TUPLE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_UNFOLD_LIST', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_BOGUS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_FLOAT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LIST_TO_TUPLE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TUPLE_TO_LIST', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_INTEGER', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_ATOM', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_FLOAT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_LIST', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_TUPLE', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_BOOLEAN', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_NUMBER', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_BITSTRING', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_FUN', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IS_FUN_WITH_ARITY', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_PLUS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MINUS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TIMES', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_RDIV', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_IDIV_NAT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_REM_NAT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_UNARY', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_POW', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TRUNC', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_ATOM_NIL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_ATOM_HEAD', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_ATOM_TAIL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_HD', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_CONS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_TCONS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_EQUAL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_UNEQUAL', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LT_INT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_LT_FLOAT', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_MAKE_BITSTR', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_EMPTY_BITSTR', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_NONEMPTY_BITSTR', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_CONCAT_SEGS', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_BITMATCH_CONST_TRUE',
		       _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_BITMATCH_CONST_FALSE',
		       _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_BITMATCH_VAR_TRUE', _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_BITMATCH_VAR_FALSE',
		       _Path) ->
    ok;
'v_enum_LogEntry.Type'('OP_BAND', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_BXOR', _Path) -> ok;
'v_enum_LogEntry.Type'('OP_BOR', _Path) -> ok;
'v_enum_LogEntry.Type'(V, Path) when is_integer(V) ->
    v_type_sint32(V, Path);
'v_enum_LogEntry.Type'(X, Path) ->
    mk_type_error({invalid_enum, 'LogEntry.Type'}, X, Path).

'v_enum_ErlangTerm.Type'('INTEGER', _Path) -> ok;
'v_enum_ErlangTerm.Type'('FLOAT', _Path) -> ok;
'v_enum_ErlangTerm.Type'('ATOM', _Path) -> ok;
'v_enum_ErlangTerm.Type'('TUPLE', _Path) -> ok;
'v_enum_ErlangTerm.Type'('LIST', _Path) -> ok;
'v_enum_ErlangTerm.Type'('IMPROPER_LIST', _Path) -> ok;
'v_enum_ErlangTerm.Type'('PID', _Path) -> ok;
'v_enum_ErlangTerm.Type'('REFERENCE', _Path) -> ok;
'v_enum_ErlangTerm.Type'('BITSTRING', _Path) -> ok;
'v_enum_ErlangTerm.Type'('MAP', _Path) -> ok;
'v_enum_ErlangTerm.Type'('FUN', _Path) -> ok;
'v_enum_ErlangTerm.Type'('SYMBOLIC_VARIABLE', _Path) ->
    ok;
'v_enum_ErlangTerm.Type'('SUBTERM', _Path) -> ok;
'v_enum_ErlangTerm.Type'('ANY', _Path) -> ok;
'v_enum_ErlangTerm.Type'(V, Path) when is_integer(V) ->
    v_type_sint32(V, Path);
'v_enum_ErlangTerm.Type'(X, Path) ->
    mk_type_error({invalid_enum, 'ErlangTerm.Type'}, X,
		  Path).

'v_enum_Spec.ErlType'('ANY', _Path) -> ok;
'v_enum_Spec.ErlType'('ATOM', _Path) -> ok;
'v_enum_Spec.ErlType'('ATOM_LITERAL', _Path) -> ok;
'v_enum_Spec.ErlType'('FLOAT', _Path) -> ok;
'v_enum_Spec.ErlType'('INTEGER', _Path) -> ok;
'v_enum_Spec.ErlType'('INTEGER_LITERAL', _Path) -> ok;
'v_enum_Spec.ErlType'('LIST', _Path) -> ok;
'v_enum_Spec.ErlType'('NONEMPTY_LIST', _Path) -> ok;
'v_enum_Spec.ErlType'('NIL', _Path) -> ok;
'v_enum_Spec.ErlType'('BITSTRING', _Path) -> ok;
'v_enum_Spec.ErlType'('TUPLE', _Path) -> ok;
'v_enum_Spec.ErlType'('TUPLEDET', _Path) -> ok;
'v_enum_Spec.ErlType'('UNION', _Path) -> ok;
'v_enum_Spec.ErlType'('RANGE', _Path) -> ok;
'v_enum_Spec.ErlType'('FUN', _Path) -> ok;
'v_enum_Spec.ErlType'('CONS', _Path) -> ok;
'v_enum_Spec.ErlType'('NTUPLE', _Path) -> ok;
'v_enum_Spec.ErlType'('USERDEF', _Path) -> ok;
'v_enum_Spec.ErlType'(V, Path) when is_integer(V) ->
    v_type_sint32(V, Path);
'v_enum_Spec.ErlType'(X, Path) ->
    mk_type_error({invalid_enum, 'Spec.ErlType'}, X, Path).

v_type_sint32(N, _Path)
    when -2147483648 =< N, N =< 2147483647 ->
    ok;
v_type_sint32(N, Path) when is_integer(N) ->
    mk_type_error({value_out_of_range, sint32, signed, 32},
		  N, Path);
v_type_sint32(X, Path) ->
    mk_type_error({bad_integer, sint32, signed, 32}, X,
		  Path).

v_type_int32(N, _Path)
    when -2147483648 =< N, N =< 2147483647 ->
    ok;
v_type_int32(N, Path) when is_integer(N) ->
    mk_type_error({value_out_of_range, int32, signed, 32},
		  N, Path);
v_type_int32(X, Path) ->
    mk_type_error({bad_integer, int32, signed, 32}, X,
		  Path).

v_type_uint32(N, _Path) when 0 =< N, N =< 4294967295 ->
    ok;
v_type_uint32(N, Path) when is_integer(N) ->
    mk_type_error({value_out_of_range, uint32, unsigned,
		   32},
		  N, Path);
v_type_uint32(X, Path) ->
    mk_type_error({bad_integer, uint32, unsigned, 32}, X,
		  Path).

v_type_uint64(N, _Path)
    when 0 =< N, N =< 18446744073709551615 ->
    ok;
v_type_uint64(N, Path) when is_integer(N) ->
    mk_type_error({value_out_of_range, uint64, unsigned,
		   64},
		  N, Path);
v_type_uint64(X, Path) ->
    mk_type_error({bad_integer, uint64, unsigned, 64}, X,
		  Path).

v_type_bool(false, _Path) -> ok;
v_type_bool(true, _Path) -> ok;
v_type_bool(0, _Path) -> ok;
v_type_bool(1, _Path) -> ok;
v_type_bool(X, Path) ->
    mk_type_error(bad_boolean_value, X, Path).

v_type_string(S, Path) when is_list(S); is_binary(S) ->
    try unicode:characters_to_binary(S) of
      B when is_binary(B) -> ok;
      {error, _, _} ->
	  mk_type_error(bad_unicode_string, S, Path)
    catch
      error:badarg ->
	  mk_type_error(bad_unicode_string, S, Path)
    end;
v_type_string(X, Path) ->
    mk_type_error(bad_unicode_string, X, Path).

'v_map<string,ErlangTerm>'(KVs, Path, TrUserData)
    when is_list(KVs) ->
    [case X of
       {Key, Value} ->
	   v_type_string(Key, [key | Path]),
	   v_msg_ErlangTerm(Value, [value | Path], TrUserData);
       _ -> mk_type_error(invalid_key_value_tuple, X, Path)
     end
     || X <- KVs],
    ok;
'v_map<string,ErlangTerm>'(X, Path, _TrUserData) ->
    mk_type_error(invalid_list_of_key_value_tuples, X,
		  Path).

-spec mk_type_error(_, _, list()) -> no_return().
mk_type_error(Error, ValueSeen, Path) ->
    Path2 = prettify_path(Path),
    erlang:error({gpb_type_error,
		  {Error, [{value, ValueSeen}, {path, Path2}]}}).


prettify_path([]) -> top_level;
prettify_path(PathR) ->
    list_to_atom(string:join(lists:map(fun atom_to_list/1,
				       lists:reverse(PathR)),
			     ".")).



-compile({inline,id/2}).
id(X, _TrUserData) -> X.

-compile({inline,cons/3}).
cons(Elem, Acc, _TrUserData) -> [Elem | Acc].

-compile({inline,lists_reverse/2}).
'lists_reverse'(L, _TrUserData) -> lists:reverse(L).
-compile({inline,'erlang_++'/3}).
'erlang_++'(A, B, _TrUserData) -> A ++ B.

-compile({inline,'tr_encode_ErlangTerm.shared[x]'/2}).
'tr_encode_ErlangTerm.shared[x]'(X, _) ->
    mt_maptuple_to_pseudomsg_r(X, 'map<string,ErlangTerm>').

-compile({inline,'tr_decode_init_default_ErlangTerm.shared'/2}).
'tr_decode_init_default_ErlangTerm.shared'(_, _) ->
    mt_empty_map_r().

-compile({inline,'tr_decode_repeated_add_elem_ErlangTerm.shared'/3}).
'tr_decode_repeated_add_elem_ErlangTerm.shared'(Elem, L,
						_) ->
    mt_add_item_r(Elem, L).

-compile({inline,'tr_decode_repeated_finalize_ErlangTerm.shared'/2}).
'tr_decode_repeated_finalize_ErlangTerm.shared'(L, _) ->
    mt_finalize_items_r(L).

-compile({inline,'tr_merge_ErlangTerm.shared'/3}).
'tr_merge_ErlangTerm.shared'(X1, X2, _) ->
    mt_merge_maptuples_r(X1, X2).

-compile({inline,mt_maptuple_to_pseudomsg_r/2}).
mt_maptuple_to_pseudomsg_r({K, V}, RName) ->
    {RName, K, V}.


-compile({inline,mt_empty_map_r/0}).
mt_empty_map_r() -> dict:new().

-compile({inline,mt_add_item_r/2}).
mt_add_item_r({_RName, K, V}, D) -> dict:store(K, V, D).


-compile({inline,mt_finalize_items_r/1}).
mt_finalize_items_r(D) -> dict:to_list(D).


-compile({inline,mt_merge_maptuples_r/2}).
mt_merge_maptuples_r(L1, L2) ->
    dict:to_list(dict:merge(fun (_Key, _V1, V2) -> V2 end,
			    dict:from_list(L1), dict:from_list(L2))).




get_msg_defs() ->
    [{{enum, 'LogEntry.Type'},
      [{'OP_PARAMS', 0}, {'OP_SPEC', 1}, {'OP_LAMBDA', 2},
       {'OP_EVALUATED_CLOSURE', 3},
       {'OP_FRESH_LAMBDA_WITH_ARITY', 4},
       {'OP_NOT_LAMBDA_WITH_ARITY', 5}, {'OP_GUARD_TRUE', 6},
       {'OP_GUARD_FALSE', 7}, {'OP_MATCH_EQUAL_TRUE', 8},
       {'OP_MATCH_EQUAL_FALSE', 9}, {'OP_TUPLE_SZ', 10},
       {'OP_TUPLE_NOT_SZ', 11}, {'OP_TUPLE_NOT_TPL', 12},
       {'OP_LIST_NON_EMPTY', 13}, {'OP_LIST_EMPTY', 14},
       {'OP_LIST_NOT_LST', 15}, {'OP_SPAWN', 16},
       {'OP_SPAWNED', 17}, {'OP_MSG_SEND', 18},
       {'OP_MSG_RECEIVE', 19}, {'OP_MSG_CONSUME', 20},
       {'OP_UNFOLD_TUPLE', 21}, {'OP_UNFOLD_LIST', 22},
       {'OP_BOGUS', 23}, {'OP_FLOAT', 24},
       {'OP_LIST_TO_TUPLE', 25}, {'OP_TUPLE_TO_LIST', 26},
       {'OP_IS_INTEGER', 27}, {'OP_IS_ATOM', 28},
       {'OP_IS_FLOAT', 29}, {'OP_IS_LIST', 30},
       {'OP_IS_TUPLE', 31}, {'OP_IS_BOOLEAN', 32},
       {'OP_IS_NUMBER', 33}, {'OP_IS_BITSTRING', 34},
       {'OP_IS_FUN', 35}, {'OP_IS_FUN_WITH_ARITY', 36},
       {'OP_PLUS', 37}, {'OP_MINUS', 38}, {'OP_TIMES', 39},
       {'OP_RDIV', 40}, {'OP_IDIV_NAT', 41},
       {'OP_REM_NAT', 42}, {'OP_UNARY', 43}, {'OP_POW', 44},
       {'OP_TRUNC', 45}, {'OP_ATOM_NIL', 46},
       {'OP_ATOM_HEAD', 47}, {'OP_ATOM_TAIL', 48},
       {'OP_HD', 49}, {'OP_TL', 50}, {'OP_CONS', 51},
       {'OP_TCONS', 52}, {'OP_EQUAL', 53}, {'OP_UNEQUAL', 54},
       {'OP_LT_INT', 55}, {'OP_LT_FLOAT', 56},
       {'OP_MAKE_BITSTR', 57}, {'OP_EMPTY_BITSTR', 58},
       {'OP_NONEMPTY_BITSTR', 59}, {'OP_CONCAT_SEGS', 60},
       {'OP_BITMATCH_CONST_TRUE', 61},
       {'OP_BITMATCH_CONST_FALSE', 62},
       {'OP_BITMATCH_VAR_TRUE', 63},
       {'OP_BITMATCH_VAR_FALSE', 64}, {'OP_BAND', 65},
       {'OP_BXOR', 66}, {'OP_BOR', 67}]},
     {{enum, 'ErlangTerm.Type'},
      [{'INTEGER', 0}, {'FLOAT', 1}, {'ATOM', 2},
       {'TUPLE', 3}, {'LIST', 4}, {'IMPROPER_LIST', 5},
       {'PID', 6}, {'REFERENCE', 7}, {'BITSTRING', 8},
       {'MAP', 9}, {'FUN', 10}, {'SYMBOLIC_VARIABLE', 11},
       {'SUBTERM', 12}, {'ANY', 13}]},
     {{enum, 'Spec.ErlType'},
      [{'ANY', 0}, {'ATOM', 1}, {'ATOM_LITERAL', 2},
       {'FLOAT', 3}, {'INTEGER', 4}, {'INTEGER_LITERAL', 5},
       {'LIST', 6}, {'NONEMPTY_LIST', 7}, {'NIL', 8},
       {'BITSTRING', 9}, {'TUPLE', 10}, {'TUPLEDET', 11},
       {'UNION', 12}, {'RANGE', 13}, {'FUN', 14}, {'CONS', 15},
       {'NTUPLE', 16}, {'USERDEF', 17}]},
     {{msg, 'LogEntry'},
      [#field{name = type, fnum = 1, rnum = 2,
	      type = {enum, 'LogEntry.Type'}, occurrence = optional,
	      opts = []},
       #field{name = arguments, fnum = 2, rnum = 3,
	      type = {msg, 'ErlangTerm'}, occurrence = repeated,
	      opts = []},
       #field{name = is_constraint, fnum = 3, rnum = 4,
	      type = bool, occurrence = optional, opts = []},
       #field{name = tag, fnum = 4, rnum = 5, type = uint64,
	      occurrence = optional, opts = []},
       #field{name = spec, fnum = 5, rnum = 6,
	      type = {msg, 'Spec'}, occurrence = optional,
	      opts = []}]},
     {{msg, 'ErlangTerm.MapEntry'},
      [#field{name = key, fnum = 1, rnum = 2,
	      type = {msg, 'ErlangTerm'}, occurrence = optional,
	      opts = []},
       #field{name = value, fnum = 2, rnum = 3,
	      type = {msg, 'ErlangTerm'}, occurrence = optional,
	      opts = []}]},
     {{msg, 'ErlangTerm.FunEntry'},
      [#field{name = arguments, fnum = 1, rnum = 2,
	      type = {msg, 'ErlangTerm'}, occurrence = repeated,
	      opts = []},
       #field{name = value, fnum = 2, rnum = 3,
	      type = {msg, 'ErlangTerm'}, occurrence = optional,
	      opts = []}]},
     {{msg, 'ErlangTerm'},
      [#field{name = type, fnum = 1, rnum = 2,
	      type = {enum, 'ErlangTerm.Type'}, occurrence = optional,
	      opts = []},
       #field{name = value, fnum = 2, rnum = 3, type = string,
	      occurrence = optional, opts = []},
       #field{name = subterms, fnum = 3, rnum = 4,
	      type = {msg, 'ErlangTerm'}, occurrence = repeated,
	      opts = []},
       #field{name = shared, fnum = 4, rnum = 5,
	      type = {map, string, {msg, 'ErlangTerm'}},
	      occurrence = repeated, opts = []},
       #field{name = improper_list_nil, fnum = 5, rnum = 6,
	      type = {msg, 'ErlangTerm'}, occurrence = optional,
	      opts = []},
       #field{name = atom_chars, fnum = 6, rnum = 7,
	      type = int32, occurrence = repeated, opts = [packed]},
       #field{name = bits, fnum = 7, rnum = 8, type = bool,
	      occurrence = repeated, opts = [packed]},
       #field{name = map_entries, fnum = 8, rnum = 9,
	      type = {msg, 'ErlangTerm.MapEntry'},
	      occurrence = repeated, opts = []},
       #field{name = points, fnum = 9, rnum = 10,
	      type = {msg, 'ErlangTerm.FunEntry'},
	      occurrence = repeated, opts = []},
       #field{name = otherwise, fnum = 10, rnum = 11,
	      type = {msg, 'ErlangTerm'}, occurrence = optional,
	      opts = []},
       #field{name = arity, fnum = 11, rnum = 12, type = int32,
	      occurrence = optional, opts = []}]},
     {{msg, 'Spec.TypeDef'},
      [#field{name = name, fnum = 1, rnum = 2, type = string,
	      occurrence = optional, opts = []},
       #field{name = definition, fnum = 2, rnum = 3,
	      type = {msg, 'Spec.Type'}, occurrence = optional,
	      opts = []}]},
     {{msg, 'Spec.RangeBounds'},
      [#field{name = lower_bound, fnum = 1, rnum = 2,
	      type = string, occurrence = optional, opts = []},
       #field{name = upper_bound, fnum = 2, rnum = 3,
	      type = string, occurrence = optional, opts = []}]},
     {{msg, 'Spec.SegmentSize'},
      [#field{name = m, fnum = 1, rnum = 2, type = string,
	      occurrence = optional, opts = []},
       #field{name = n, fnum = 2, rnum = 3, type = string,
	      occurrence = optional, opts = []}]},
     {{msg, 'Spec.FunSig'},
      [#gpb_oneof{name = signature, rnum = 2,
		  fields =
		      [#field{name = complete, fnum = 1, rnum = 2,
			      type = {msg, 'Spec.FunDet'},
			      occurrence = optional, opts = []},
		       #field{name = just_return, fnum = 2, rnum = 2,
			      type = {msg, 'Spec.Type'}, occurrence = optional,
			      opts = []}]}]},
     {{msg, 'Spec.FunDet'},
      [#field{name = parameters, fnum = 1, rnum = 2,
	      type = {msg, 'Spec.Type'}, occurrence = repeated,
	      opts = []},
       #field{name = return_value, fnum = 2, rnum = 3,
	      type = {msg, 'Spec.Type'}, occurrence = optional,
	      opts = []}]},
     {{msg, 'Spec.Type'},
      [#field{name = type, fnum = 1, rnum = 2,
	      type = {enum, 'Spec.ErlType'}, occurrence = optional,
	      opts = []},
       #gpb_oneof{name = arg, rnum = 3,
		  fields =
		      [#field{name = literal, fnum = 2, rnum = 3,
			      type = {msg, 'ErlangTerm'}, occurrence = optional,
			      opts = []},
		       #field{name = range_bounds, fnum = 3, rnum = 3,
			      type = {msg, 'Spec.RangeBounds'},
			      occurrence = optional, opts = []},
		       #field{name = segment_size, fnum = 4, rnum = 3,
			      type = {msg, 'Spec.SegmentSize'},
			      occurrence = optional, opts = []},
		       #field{name = inner_type, fnum = 5, rnum = 3,
			      type = {msg, 'Spec.Type'}, occurrence = optional,
			      opts = []},
		       #field{name = inner_types, fnum = 6, rnum = 3,
			      type = {msg, 'Spec.TypeList'},
			      occurrence = optional, opts = []},
		       #field{name = 'fun', fnum = 7, rnum = 3,
			      type = {msg, 'Spec.FunSig'},
			      occurrence = optional, opts = []},
		       #field{name = ntuple_size, fnum = 8, rnum = 3,
			      type = uint32, occurrence = optional, opts = []},
		       #field{name = type_name, fnum = 9, rnum = 3,
			      type = string, occurrence = optional,
			      opts = []}]}]},
     {{msg, 'Spec.TypeList'},
      [#field{name = types, fnum = 1, rnum = 2,
	      type = {msg, 'Spec.Type'}, occurrence = repeated,
	      opts = []}]},
     {{msg, 'Spec'},
      [#field{name = clauses, fnum = 1, rnum = 2,
	      type = {msg, 'Spec.FunSig'}, occurrence = repeated,
	      opts = []},
       #field{name = typedefs, fnum = 2, rnum = 3,
	      type = {msg, 'Spec.TypeDef'}, occurrence = repeated,
	      opts = []}]}].


get_msg_names() ->
    ['LogEntry', 'ErlangTerm.MapEntry',
     'ErlangTerm.FunEntry', 'ErlangTerm', 'Spec.TypeDef',
     'Spec.RangeBounds', 'Spec.SegmentSize', 'Spec.FunSig',
     'Spec.FunDet', 'Spec.Type', 'Spec.TypeList', 'Spec'].


get_enum_names() ->
    ['LogEntry.Type', 'ErlangTerm.Type', 'Spec.ErlType'].


fetch_msg_def(MsgName) ->
    case find_msg_def(MsgName) of
      Fs when is_list(Fs) -> Fs;
      error -> erlang:error({no_such_msg, MsgName})
    end.


fetch_enum_def(EnumName) ->
    case find_enum_def(EnumName) of
      Es when is_list(Es) -> Es;
      error -> erlang:error({no_such_enum, EnumName})
    end.


find_msg_def('LogEntry') ->
    [#field{name = type, fnum = 1, rnum = 2,
	    type = {enum, 'LogEntry.Type'}, occurrence = optional,
	    opts = []},
     #field{name = arguments, fnum = 2, rnum = 3,
	    type = {msg, 'ErlangTerm'}, occurrence = repeated,
	    opts = []},
     #field{name = is_constraint, fnum = 3, rnum = 4,
	    type = bool, occurrence = optional, opts = []},
     #field{name = tag, fnum = 4, rnum = 5, type = uint64,
	    occurrence = optional, opts = []},
     #field{name = spec, fnum = 5, rnum = 6,
	    type = {msg, 'Spec'}, occurrence = optional,
	    opts = []}];
find_msg_def('ErlangTerm.MapEntry') ->
    [#field{name = key, fnum = 1, rnum = 2,
	    type = {msg, 'ErlangTerm'}, occurrence = optional,
	    opts = []},
     #field{name = value, fnum = 2, rnum = 3,
	    type = {msg, 'ErlangTerm'}, occurrence = optional,
	    opts = []}];
find_msg_def('ErlangTerm.FunEntry') ->
    [#field{name = arguments, fnum = 1, rnum = 2,
	    type = {msg, 'ErlangTerm'}, occurrence = repeated,
	    opts = []},
     #field{name = value, fnum = 2, rnum = 3,
	    type = {msg, 'ErlangTerm'}, occurrence = optional,
	    opts = []}];
find_msg_def('ErlangTerm') ->
    [#field{name = type, fnum = 1, rnum = 2,
	    type = {enum, 'ErlangTerm.Type'}, occurrence = optional,
	    opts = []},
     #field{name = value, fnum = 2, rnum = 3, type = string,
	    occurrence = optional, opts = []},
     #field{name = subterms, fnum = 3, rnum = 4,
	    type = {msg, 'ErlangTerm'}, occurrence = repeated,
	    opts = []},
     #field{name = shared, fnum = 4, rnum = 5,
	    type = {map, string, {msg, 'ErlangTerm'}},
	    occurrence = repeated, opts = []},
     #field{name = improper_list_nil, fnum = 5, rnum = 6,
	    type = {msg, 'ErlangTerm'}, occurrence = optional,
	    opts = []},
     #field{name = atom_chars, fnum = 6, rnum = 7,
	    type = int32, occurrence = repeated, opts = [packed]},
     #field{name = bits, fnum = 7, rnum = 8, type = bool,
	    occurrence = repeated, opts = [packed]},
     #field{name = map_entries, fnum = 8, rnum = 9,
	    type = {msg, 'ErlangTerm.MapEntry'},
	    occurrence = repeated, opts = []},
     #field{name = points, fnum = 9, rnum = 10,
	    type = {msg, 'ErlangTerm.FunEntry'},
	    occurrence = repeated, opts = []},
     #field{name = otherwise, fnum = 10, rnum = 11,
	    type = {msg, 'ErlangTerm'}, occurrence = optional,
	    opts = []},
     #field{name = arity, fnum = 11, rnum = 12, type = int32,
	    occurrence = optional, opts = []}];
find_msg_def('Spec.TypeDef') ->
    [#field{name = name, fnum = 1, rnum = 2, type = string,
	    occurrence = optional, opts = []},
     #field{name = definition, fnum = 2, rnum = 3,
	    type = {msg, 'Spec.Type'}, occurrence = optional,
	    opts = []}];
find_msg_def('Spec.RangeBounds') ->
    [#field{name = lower_bound, fnum = 1, rnum = 2,
	    type = string, occurrence = optional, opts = []},
     #field{name = upper_bound, fnum = 2, rnum = 3,
	    type = string, occurrence = optional, opts = []}];
find_msg_def('Spec.SegmentSize') ->
    [#field{name = m, fnum = 1, rnum = 2, type = string,
	    occurrence = optional, opts = []},
     #field{name = n, fnum = 2, rnum = 3, type = string,
	    occurrence = optional, opts = []}];
find_msg_def('Spec.FunSig') ->
    [#gpb_oneof{name = signature, rnum = 2,
		fields =
		    [#field{name = complete, fnum = 1, rnum = 2,
			    type = {msg, 'Spec.FunDet'}, occurrence = optional,
			    opts = []},
		     #field{name = just_return, fnum = 2, rnum = 2,
			    type = {msg, 'Spec.Type'}, occurrence = optional,
			    opts = []}]}];
find_msg_def('Spec.FunDet') ->
    [#field{name = parameters, fnum = 1, rnum = 2,
	    type = {msg, 'Spec.Type'}, occurrence = repeated,
	    opts = []},
     #field{name = return_value, fnum = 2, rnum = 3,
	    type = {msg, 'Spec.Type'}, occurrence = optional,
	    opts = []}];
find_msg_def('Spec.Type') ->
    [#field{name = type, fnum = 1, rnum = 2,
	    type = {enum, 'Spec.ErlType'}, occurrence = optional,
	    opts = []},
     #gpb_oneof{name = arg, rnum = 3,
		fields =
		    [#field{name = literal, fnum = 2, rnum = 3,
			    type = {msg, 'ErlangTerm'}, occurrence = optional,
			    opts = []},
		     #field{name = range_bounds, fnum = 3, rnum = 3,
			    type = {msg, 'Spec.RangeBounds'},
			    occurrence = optional, opts = []},
		     #field{name = segment_size, fnum = 4, rnum = 3,
			    type = {msg, 'Spec.SegmentSize'},
			    occurrence = optional, opts = []},
		     #field{name = inner_type, fnum = 5, rnum = 3,
			    type = {msg, 'Spec.Type'}, occurrence = optional,
			    opts = []},
		     #field{name = inner_types, fnum = 6, rnum = 3,
			    type = {msg, 'Spec.TypeList'},
			    occurrence = optional, opts = []},
		     #field{name = 'fun', fnum = 7, rnum = 3,
			    type = {msg, 'Spec.FunSig'}, occurrence = optional,
			    opts = []},
		     #field{name = ntuple_size, fnum = 8, rnum = 3,
			    type = uint32, occurrence = optional, opts = []},
		     #field{name = type_name, fnum = 9, rnum = 3,
			    type = string, occurrence = optional, opts = []}]}];
find_msg_def('Spec.TypeList') ->
    [#field{name = types, fnum = 1, rnum = 2,
	    type = {msg, 'Spec.Type'}, occurrence = repeated,
	    opts = []}];
find_msg_def('Spec') ->
    [#field{name = clauses, fnum = 1, rnum = 2,
	    type = {msg, 'Spec.FunSig'}, occurrence = repeated,
	    opts = []},
     #field{name = typedefs, fnum = 2, rnum = 3,
	    type = {msg, 'Spec.TypeDef'}, occurrence = repeated,
	    opts = []}];
find_msg_def(_) -> error.


find_enum_def('LogEntry.Type') ->
    [{'OP_PARAMS', 0}, {'OP_SPEC', 1}, {'OP_LAMBDA', 2},
     {'OP_EVALUATED_CLOSURE', 3},
     {'OP_FRESH_LAMBDA_WITH_ARITY', 4},
     {'OP_NOT_LAMBDA_WITH_ARITY', 5}, {'OP_GUARD_TRUE', 6},
     {'OP_GUARD_FALSE', 7}, {'OP_MATCH_EQUAL_TRUE', 8},
     {'OP_MATCH_EQUAL_FALSE', 9}, {'OP_TUPLE_SZ', 10},
     {'OP_TUPLE_NOT_SZ', 11}, {'OP_TUPLE_NOT_TPL', 12},
     {'OP_LIST_NON_EMPTY', 13}, {'OP_LIST_EMPTY', 14},
     {'OP_LIST_NOT_LST', 15}, {'OP_SPAWN', 16},
     {'OP_SPAWNED', 17}, {'OP_MSG_SEND', 18},
     {'OP_MSG_RECEIVE', 19}, {'OP_MSG_CONSUME', 20},
     {'OP_UNFOLD_TUPLE', 21}, {'OP_UNFOLD_LIST', 22},
     {'OP_BOGUS', 23}, {'OP_FLOAT', 24},
     {'OP_LIST_TO_TUPLE', 25}, {'OP_TUPLE_TO_LIST', 26},
     {'OP_IS_INTEGER', 27}, {'OP_IS_ATOM', 28},
     {'OP_IS_FLOAT', 29}, {'OP_IS_LIST', 30},
     {'OP_IS_TUPLE', 31}, {'OP_IS_BOOLEAN', 32},
     {'OP_IS_NUMBER', 33}, {'OP_IS_BITSTRING', 34},
     {'OP_IS_FUN', 35}, {'OP_IS_FUN_WITH_ARITY', 36},
     {'OP_PLUS', 37}, {'OP_MINUS', 38}, {'OP_TIMES', 39},
     {'OP_RDIV', 40}, {'OP_IDIV_NAT', 41},
     {'OP_REM_NAT', 42}, {'OP_UNARY', 43}, {'OP_POW', 44},
     {'OP_TRUNC', 45}, {'OP_ATOM_NIL', 46},
     {'OP_ATOM_HEAD', 47}, {'OP_ATOM_TAIL', 48},
     {'OP_HD', 49}, {'OP_TL', 50}, {'OP_CONS', 51},
     {'OP_TCONS', 52}, {'OP_EQUAL', 53}, {'OP_UNEQUAL', 54},
     {'OP_LT_INT', 55}, {'OP_LT_FLOAT', 56},
     {'OP_MAKE_BITSTR', 57}, {'OP_EMPTY_BITSTR', 58},
     {'OP_NONEMPTY_BITSTR', 59}, {'OP_CONCAT_SEGS', 60},
     {'OP_BITMATCH_CONST_TRUE', 61},
     {'OP_BITMATCH_CONST_FALSE', 62},
     {'OP_BITMATCH_VAR_TRUE', 63},
     {'OP_BITMATCH_VAR_FALSE', 64}, {'OP_BAND', 65},
     {'OP_BXOR', 66}, {'OP_BOR', 67}];
find_enum_def('ErlangTerm.Type') ->
    [{'INTEGER', 0}, {'FLOAT', 1}, {'ATOM', 2},
     {'TUPLE', 3}, {'LIST', 4}, {'IMPROPER_LIST', 5},
     {'PID', 6}, {'REFERENCE', 7}, {'BITSTRING', 8},
     {'MAP', 9}, {'FUN', 10}, {'SYMBOLIC_VARIABLE', 11},
     {'SUBTERM', 12}, {'ANY', 13}];
find_enum_def('Spec.ErlType') ->
    [{'ANY', 0}, {'ATOM', 1}, {'ATOM_LITERAL', 2},
     {'FLOAT', 3}, {'INTEGER', 4}, {'INTEGER_LITERAL', 5},
     {'LIST', 6}, {'NONEMPTY_LIST', 7}, {'NIL', 8},
     {'BITSTRING', 9}, {'TUPLE', 10}, {'TUPLEDET', 11},
     {'UNION', 12}, {'RANGE', 13}, {'FUN', 14}, {'CONS', 15},
     {'NTUPLE', 16}, {'USERDEF', 17}];
find_enum_def(_) -> error.


enum_symbol_by_value('LogEntry.Type', Value) ->
    'enum_symbol_by_value_LogEntry.Type'(Value);
enum_symbol_by_value('ErlangTerm.Type', Value) ->
    'enum_symbol_by_value_ErlangTerm.Type'(Value);
enum_symbol_by_value('Spec.ErlType', Value) ->
    'enum_symbol_by_value_Spec.ErlType'(Value).


enum_value_by_symbol('LogEntry.Type', Sym) ->
    'enum_value_by_symbol_LogEntry.Type'(Sym);
enum_value_by_symbol('ErlangTerm.Type', Sym) ->
    'enum_value_by_symbol_ErlangTerm.Type'(Sym);
enum_value_by_symbol('Spec.ErlType', Sym) ->
    'enum_value_by_symbol_Spec.ErlType'(Sym).


'enum_symbol_by_value_LogEntry.Type'(0) -> 'OP_PARAMS';
'enum_symbol_by_value_LogEntry.Type'(1) -> 'OP_SPEC';
'enum_symbol_by_value_LogEntry.Type'(2) -> 'OP_LAMBDA';
'enum_symbol_by_value_LogEntry.Type'(3) ->
    'OP_EVALUATED_CLOSURE';
'enum_symbol_by_value_LogEntry.Type'(4) ->
    'OP_FRESH_LAMBDA_WITH_ARITY';
'enum_symbol_by_value_LogEntry.Type'(5) ->
    'OP_NOT_LAMBDA_WITH_ARITY';
'enum_symbol_by_value_LogEntry.Type'(6) ->
    'OP_GUARD_TRUE';
'enum_symbol_by_value_LogEntry.Type'(7) ->
    'OP_GUARD_FALSE';
'enum_symbol_by_value_LogEntry.Type'(8) ->
    'OP_MATCH_EQUAL_TRUE';
'enum_symbol_by_value_LogEntry.Type'(9) ->
    'OP_MATCH_EQUAL_FALSE';
'enum_symbol_by_value_LogEntry.Type'(10) ->
    'OP_TUPLE_SZ';
'enum_symbol_by_value_LogEntry.Type'(11) ->
    'OP_TUPLE_NOT_SZ';
'enum_symbol_by_value_LogEntry.Type'(12) ->
    'OP_TUPLE_NOT_TPL';
'enum_symbol_by_value_LogEntry.Type'(13) ->
    'OP_LIST_NON_EMPTY';
'enum_symbol_by_value_LogEntry.Type'(14) ->
    'OP_LIST_EMPTY';
'enum_symbol_by_value_LogEntry.Type'(15) ->
    'OP_LIST_NOT_LST';
'enum_symbol_by_value_LogEntry.Type'(16) -> 'OP_SPAWN';
'enum_symbol_by_value_LogEntry.Type'(17) ->
    'OP_SPAWNED';
'enum_symbol_by_value_LogEntry.Type'(18) ->
    'OP_MSG_SEND';
'enum_symbol_by_value_LogEntry.Type'(19) ->
    'OP_MSG_RECEIVE';
'enum_symbol_by_value_LogEntry.Type'(20) ->
    'OP_MSG_CONSUME';
'enum_symbol_by_value_LogEntry.Type'(21) ->
    'OP_UNFOLD_TUPLE';
'enum_symbol_by_value_LogEntry.Type'(22) ->
    'OP_UNFOLD_LIST';
'enum_symbol_by_value_LogEntry.Type'(23) -> 'OP_BOGUS';
'enum_symbol_by_value_LogEntry.Type'(24) -> 'OP_FLOAT';
'enum_symbol_by_value_LogEntry.Type'(25) ->
    'OP_LIST_TO_TUPLE';
'enum_symbol_by_value_LogEntry.Type'(26) ->
    'OP_TUPLE_TO_LIST';
'enum_symbol_by_value_LogEntry.Type'(27) ->
    'OP_IS_INTEGER';
'enum_symbol_by_value_LogEntry.Type'(28) ->
    'OP_IS_ATOM';
'enum_symbol_by_value_LogEntry.Type'(29) ->
    'OP_IS_FLOAT';
'enum_symbol_by_value_LogEntry.Type'(30) ->
    'OP_IS_LIST';
'enum_symbol_by_value_LogEntry.Type'(31) ->
    'OP_IS_TUPLE';
'enum_symbol_by_value_LogEntry.Type'(32) ->
    'OP_IS_BOOLEAN';
'enum_symbol_by_value_LogEntry.Type'(33) ->
    'OP_IS_NUMBER';
'enum_symbol_by_value_LogEntry.Type'(34) ->
    'OP_IS_BITSTRING';
'enum_symbol_by_value_LogEntry.Type'(35) -> 'OP_IS_FUN';
'enum_symbol_by_value_LogEntry.Type'(36) ->
    'OP_IS_FUN_WITH_ARITY';
'enum_symbol_by_value_LogEntry.Type'(37) -> 'OP_PLUS';
'enum_symbol_by_value_LogEntry.Type'(38) -> 'OP_MINUS';
'enum_symbol_by_value_LogEntry.Type'(39) -> 'OP_TIMES';
'enum_symbol_by_value_LogEntry.Type'(40) -> 'OP_RDIV';
'enum_symbol_by_value_LogEntry.Type'(41) ->
    'OP_IDIV_NAT';
'enum_symbol_by_value_LogEntry.Type'(42) ->
    'OP_REM_NAT';
'enum_symbol_by_value_LogEntry.Type'(43) -> 'OP_UNARY';
'enum_symbol_by_value_LogEntry.Type'(44) -> 'OP_POW';
'enum_symbol_by_value_LogEntry.Type'(45) -> 'OP_TRUNC';
'enum_symbol_by_value_LogEntry.Type'(46) ->
    'OP_ATOM_NIL';
'enum_symbol_by_value_LogEntry.Type'(47) ->
    'OP_ATOM_HEAD';
'enum_symbol_by_value_LogEntry.Type'(48) ->
    'OP_ATOM_TAIL';
'enum_symbol_by_value_LogEntry.Type'(49) -> 'OP_HD';
'enum_symbol_by_value_LogEntry.Type'(50) -> 'OP_TL';
'enum_symbol_by_value_LogEntry.Type'(51) -> 'OP_CONS';
'enum_symbol_by_value_LogEntry.Type'(52) -> 'OP_TCONS';
'enum_symbol_by_value_LogEntry.Type'(53) -> 'OP_EQUAL';
'enum_symbol_by_value_LogEntry.Type'(54) ->
    'OP_UNEQUAL';
'enum_symbol_by_value_LogEntry.Type'(55) -> 'OP_LT_INT';
'enum_symbol_by_value_LogEntry.Type'(56) ->
    'OP_LT_FLOAT';
'enum_symbol_by_value_LogEntry.Type'(57) ->
    'OP_MAKE_BITSTR';
'enum_symbol_by_value_LogEntry.Type'(58) ->
    'OP_EMPTY_BITSTR';
'enum_symbol_by_value_LogEntry.Type'(59) ->
    'OP_NONEMPTY_BITSTR';
'enum_symbol_by_value_LogEntry.Type'(60) ->
    'OP_CONCAT_SEGS';
'enum_symbol_by_value_LogEntry.Type'(61) ->
    'OP_BITMATCH_CONST_TRUE';
'enum_symbol_by_value_LogEntry.Type'(62) ->
    'OP_BITMATCH_CONST_FALSE';
'enum_symbol_by_value_LogEntry.Type'(63) ->
    'OP_BITMATCH_VAR_TRUE';
'enum_symbol_by_value_LogEntry.Type'(64) ->
    'OP_BITMATCH_VAR_FALSE';
'enum_symbol_by_value_LogEntry.Type'(65) -> 'OP_BAND';
'enum_symbol_by_value_LogEntry.Type'(66) -> 'OP_BXOR';
'enum_symbol_by_value_LogEntry.Type'(67) -> 'OP_BOR'.


'enum_value_by_symbol_LogEntry.Type'('OP_PARAMS') -> 0;
'enum_value_by_symbol_LogEntry.Type'('OP_SPEC') -> 1;
'enum_value_by_symbol_LogEntry.Type'('OP_LAMBDA') -> 2;
'enum_value_by_symbol_LogEntry.Type'('OP_EVALUATED_CLOSURE') ->
    3;
'enum_value_by_symbol_LogEntry.Type'('OP_FRESH_LAMBDA_WITH_ARITY') ->
    4;
'enum_value_by_symbol_LogEntry.Type'('OP_NOT_LAMBDA_WITH_ARITY') ->
    5;
'enum_value_by_symbol_LogEntry.Type'('OP_GUARD_TRUE') ->
    6;
'enum_value_by_symbol_LogEntry.Type'('OP_GUARD_FALSE') ->
    7;
'enum_value_by_symbol_LogEntry.Type'('OP_MATCH_EQUAL_TRUE') ->
    8;
'enum_value_by_symbol_LogEntry.Type'('OP_MATCH_EQUAL_FALSE') ->
    9;
'enum_value_by_symbol_LogEntry.Type'('OP_TUPLE_SZ') ->
    10;
'enum_value_by_symbol_LogEntry.Type'('OP_TUPLE_NOT_SZ') ->
    11;
'enum_value_by_symbol_LogEntry.Type'('OP_TUPLE_NOT_TPL') ->
    12;
'enum_value_by_symbol_LogEntry.Type'('OP_LIST_NON_EMPTY') ->
    13;
'enum_value_by_symbol_LogEntry.Type'('OP_LIST_EMPTY') ->
    14;
'enum_value_by_symbol_LogEntry.Type'('OP_LIST_NOT_LST') ->
    15;
'enum_value_by_symbol_LogEntry.Type'('OP_SPAWN') -> 16;
'enum_value_by_symbol_LogEntry.Type'('OP_SPAWNED') ->
    17;
'enum_value_by_symbol_LogEntry.Type'('OP_MSG_SEND') ->
    18;
'enum_value_by_symbol_LogEntry.Type'('OP_MSG_RECEIVE') ->
    19;
'enum_value_by_symbol_LogEntry.Type'('OP_MSG_CONSUME') ->
    20;
'enum_value_by_symbol_LogEntry.Type'('OP_UNFOLD_TUPLE') ->
    21;
'enum_value_by_symbol_LogEntry.Type'('OP_UNFOLD_LIST') ->
    22;
'enum_value_by_symbol_LogEntry.Type'('OP_BOGUS') -> 23;
'enum_value_by_symbol_LogEntry.Type'('OP_FLOAT') -> 24;
'enum_value_by_symbol_LogEntry.Type'('OP_LIST_TO_TUPLE') ->
    25;
'enum_value_by_symbol_LogEntry.Type'('OP_TUPLE_TO_LIST') ->
    26;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_INTEGER') ->
    27;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_ATOM') ->
    28;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_FLOAT') ->
    29;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_LIST') ->
    30;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_TUPLE') ->
    31;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_BOOLEAN') ->
    32;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_NUMBER') ->
    33;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_BITSTRING') ->
    34;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_FUN') -> 35;
'enum_value_by_symbol_LogEntry.Type'('OP_IS_FUN_WITH_ARITY') ->
    36;
'enum_value_by_symbol_LogEntry.Type'('OP_PLUS') -> 37;
'enum_value_by_symbol_LogEntry.Type'('OP_MINUS') -> 38;
'enum_value_by_symbol_LogEntry.Type'('OP_TIMES') -> 39;
'enum_value_by_symbol_LogEntry.Type'('OP_RDIV') -> 40;
'enum_value_by_symbol_LogEntry.Type'('OP_IDIV_NAT') ->
    41;
'enum_value_by_symbol_LogEntry.Type'('OP_REM_NAT') ->
    42;
'enum_value_by_symbol_LogEntry.Type'('OP_UNARY') -> 43;
'enum_value_by_symbol_LogEntry.Type'('OP_POW') -> 44;
'enum_value_by_symbol_LogEntry.Type'('OP_TRUNC') -> 45;
'enum_value_by_symbol_LogEntry.Type'('OP_ATOM_NIL') ->
    46;
'enum_value_by_symbol_LogEntry.Type'('OP_ATOM_HEAD') ->
    47;
'enum_value_by_symbol_LogEntry.Type'('OP_ATOM_TAIL') ->
    48;
'enum_value_by_symbol_LogEntry.Type'('OP_HD') -> 49;
'enum_value_by_symbol_LogEntry.Type'('OP_TL') -> 50;
'enum_value_by_symbol_LogEntry.Type'('OP_CONS') -> 51;
'enum_value_by_symbol_LogEntry.Type'('OP_TCONS') -> 52;
'enum_value_by_symbol_LogEntry.Type'('OP_EQUAL') -> 53;
'enum_value_by_symbol_LogEntry.Type'('OP_UNEQUAL') ->
    54;
'enum_value_by_symbol_LogEntry.Type'('OP_LT_INT') -> 55;
'enum_value_by_symbol_LogEntry.Type'('OP_LT_FLOAT') ->
    56;
'enum_value_by_symbol_LogEntry.Type'('OP_MAKE_BITSTR') ->
    57;
'enum_value_by_symbol_LogEntry.Type'('OP_EMPTY_BITSTR') ->
    58;
'enum_value_by_symbol_LogEntry.Type'('OP_NONEMPTY_BITSTR') ->
    59;
'enum_value_by_symbol_LogEntry.Type'('OP_CONCAT_SEGS') ->
    60;
'enum_value_by_symbol_LogEntry.Type'('OP_BITMATCH_CONST_TRUE') ->
    61;
'enum_value_by_symbol_LogEntry.Type'('OP_BITMATCH_CONST_FALSE') ->
    62;
'enum_value_by_symbol_LogEntry.Type'('OP_BITMATCH_VAR_TRUE') ->
    63;
'enum_value_by_symbol_LogEntry.Type'('OP_BITMATCH_VAR_FALSE') ->
    64;
'enum_value_by_symbol_LogEntry.Type'('OP_BAND') -> 65;
'enum_value_by_symbol_LogEntry.Type'('OP_BXOR') -> 66;
'enum_value_by_symbol_LogEntry.Type'('OP_BOR') -> 67.

'enum_symbol_by_value_ErlangTerm.Type'(0) -> 'INTEGER';
'enum_symbol_by_value_ErlangTerm.Type'(1) -> 'FLOAT';
'enum_symbol_by_value_ErlangTerm.Type'(2) -> 'ATOM';
'enum_symbol_by_value_ErlangTerm.Type'(3) -> 'TUPLE';
'enum_symbol_by_value_ErlangTerm.Type'(4) -> 'LIST';
'enum_symbol_by_value_ErlangTerm.Type'(5) ->
    'IMPROPER_LIST';
'enum_symbol_by_value_ErlangTerm.Type'(6) -> 'PID';
'enum_symbol_by_value_ErlangTerm.Type'(7) ->
    'REFERENCE';
'enum_symbol_by_value_ErlangTerm.Type'(8) ->
    'BITSTRING';
'enum_symbol_by_value_ErlangTerm.Type'(9) -> 'MAP';
'enum_symbol_by_value_ErlangTerm.Type'(10) -> 'FUN';
'enum_symbol_by_value_ErlangTerm.Type'(11) ->
    'SYMBOLIC_VARIABLE';
'enum_symbol_by_value_ErlangTerm.Type'(12) -> 'SUBTERM';
'enum_symbol_by_value_ErlangTerm.Type'(13) -> 'ANY'.


'enum_value_by_symbol_ErlangTerm.Type'('INTEGER') -> 0;
'enum_value_by_symbol_ErlangTerm.Type'('FLOAT') -> 1;
'enum_value_by_symbol_ErlangTerm.Type'('ATOM') -> 2;
'enum_value_by_symbol_ErlangTerm.Type'('TUPLE') -> 3;
'enum_value_by_symbol_ErlangTerm.Type'('LIST') -> 4;
'enum_value_by_symbol_ErlangTerm.Type'('IMPROPER_LIST') ->
    5;
'enum_value_by_symbol_ErlangTerm.Type'('PID') -> 6;
'enum_value_by_symbol_ErlangTerm.Type'('REFERENCE') ->
    7;
'enum_value_by_symbol_ErlangTerm.Type'('BITSTRING') ->
    8;
'enum_value_by_symbol_ErlangTerm.Type'('MAP') -> 9;
'enum_value_by_symbol_ErlangTerm.Type'('FUN') -> 10;
'enum_value_by_symbol_ErlangTerm.Type'('SYMBOLIC_VARIABLE') ->
    11;
'enum_value_by_symbol_ErlangTerm.Type'('SUBTERM') -> 12;
'enum_value_by_symbol_ErlangTerm.Type'('ANY') -> 13.

'enum_symbol_by_value_Spec.ErlType'(0) -> 'ANY';
'enum_symbol_by_value_Spec.ErlType'(1) -> 'ATOM';
'enum_symbol_by_value_Spec.ErlType'(2) ->
    'ATOM_LITERAL';
'enum_symbol_by_value_Spec.ErlType'(3) -> 'FLOAT';
'enum_symbol_by_value_Spec.ErlType'(4) -> 'INTEGER';
'enum_symbol_by_value_Spec.ErlType'(5) ->
    'INTEGER_LITERAL';
'enum_symbol_by_value_Spec.ErlType'(6) -> 'LIST';
'enum_symbol_by_value_Spec.ErlType'(7) ->
    'NONEMPTY_LIST';
'enum_symbol_by_value_Spec.ErlType'(8) -> 'NIL';
'enum_symbol_by_value_Spec.ErlType'(9) -> 'BITSTRING';
'enum_symbol_by_value_Spec.ErlType'(10) -> 'TUPLE';
'enum_symbol_by_value_Spec.ErlType'(11) -> 'TUPLEDET';
'enum_symbol_by_value_Spec.ErlType'(12) -> 'UNION';
'enum_symbol_by_value_Spec.ErlType'(13) -> 'RANGE';
'enum_symbol_by_value_Spec.ErlType'(14) -> 'FUN';
'enum_symbol_by_value_Spec.ErlType'(15) -> 'CONS';
'enum_symbol_by_value_Spec.ErlType'(16) -> 'NTUPLE';
'enum_symbol_by_value_Spec.ErlType'(17) -> 'USERDEF'.


'enum_value_by_symbol_Spec.ErlType'('ANY') -> 0;
'enum_value_by_symbol_Spec.ErlType'('ATOM') -> 1;
'enum_value_by_symbol_Spec.ErlType'('ATOM_LITERAL') ->
    2;
'enum_value_by_symbol_Spec.ErlType'('FLOAT') -> 3;
'enum_value_by_symbol_Spec.ErlType'('INTEGER') -> 4;
'enum_value_by_symbol_Spec.ErlType'('INTEGER_LITERAL') ->
    5;
'enum_value_by_symbol_Spec.ErlType'('LIST') -> 6;
'enum_value_by_symbol_Spec.ErlType'('NONEMPTY_LIST') ->
    7;
'enum_value_by_symbol_Spec.ErlType'('NIL') -> 8;
'enum_value_by_symbol_Spec.ErlType'('BITSTRING') -> 9;
'enum_value_by_symbol_Spec.ErlType'('TUPLE') -> 10;
'enum_value_by_symbol_Spec.ErlType'('TUPLEDET') -> 11;
'enum_value_by_symbol_Spec.ErlType'('UNION') -> 12;
'enum_value_by_symbol_Spec.ErlType'('RANGE') -> 13;
'enum_value_by_symbol_Spec.ErlType'('FUN') -> 14;
'enum_value_by_symbol_Spec.ErlType'('CONS') -> 15;
'enum_value_by_symbol_Spec.ErlType'('NTUPLE') -> 16;
'enum_value_by_symbol_Spec.ErlType'('USERDEF') -> 17.


get_service_names() -> [].


get_service_def(_) -> error.


get_rpc_names(_) -> error.


find_rpc_def(_, _) -> error.



-spec fetch_rpc_def(_, _) -> no_return().
fetch_rpc_def(ServiceName, RpcName) ->
    erlang:error({no_such_rpc, ServiceName, RpcName}).


get_package_name() -> undefined.



gpb_version_as_string() ->
    "3.26.4".

gpb_version_as_list() ->
    [3,26,4].
