*****************
Typer -> Proper
*****************
- Conversion de tipos Typer a tipos Proper
- Calculo de interseccion de tipos cuando una variable se utiliza varias veces en una clausula f(X,A,X)

- Los tipos son los de las spec definidas por el usuario % ACTUALMENTE
- Hacer interseccion entre tipos Typer y specs % PENDING

- Calcular tipo por clausulas utilizando typer Tama % PENDING

*************************************************
	Cuter & Random
*************************************************
Phase 1: Cuter

+ Se generan mas tests con Proper hasta: 
1.- Alcanzar la cobertura deseada %NO
2.- Alcanzar el numero maximo de tests esperados %NO
3.- Alcanzar el timeout 

***** TODO *****
+ Al seleccionar patron de clause, la guarda debe ponerse a true % DONE
+ Definir una lista de funciones como funcion de entrada % DONE
+ No definir funcion de entrada coger exports
+ En la LC el generador debe ( {A,B,C,Pi,B,D,D} <-  L) =>  ({A,B,C,Pi,FV1,D,FV2} <- L) URGENTE

+ Dividir las guardas para tener en cuenta cortocircuitados y instrumentarlo a base de cases de cases 

+ Probar si funciona en concurrencia con ejemplos deterministas de concurrencia (Para el paper)
+ Buscar un programa o diseñar uno sencillo donde tengamos 3 versiones (Vital para el paper)
1.- Programa original
2.- Version refactorizada con errores
3.- Version final sin errores

+ Parametro fun:
¿Proper genera funs? 
¿Cuter como lleva lo de las funs como parametros de entrada?

+ Reprintear el AST al principio para que la organización del mismo sea adecuada al medir la cobertura con COVER. % PENDING
+ Obtener las trazas de 2 programas en paralelo y matar la ejecución al hallar una divergencia % PENDING

+ typer_mod.erl es una fuente de error, por las distintas versiones de typer. Hay que notificar el error en la herramienta
con algun mensaje y dar una direccion github para descargar la version alternativa

***** DONE ******

+ Arreglar replace after position, entrar en profundidad en cada elemento de la izq de pos y realizar los cambios pertinentes
teniendo en cuenta lo que se sustituye a la antes al profundizar y sustituyendo cada variable con el mismo nombre por la misma
FreeVar URGENTE En principio: % DONE

+ Las trazas no vacias obtenidas por cuter se deben utilizar para generar nuevos inputs, no desecharlas % DONE
+ Detectar de que clausula es el input generado por cuter %DONE
+ Cambiar lo del offset por linea, variable y ocurrencia. Utilizar el AST para cambiar ese nodo por slicing_criterion y usar 
el nuevo AST para instrumentar directamente % DONE*
+ No sustituir por slicing_criterion sino localizar directamente el SC en la funcion get_path con la informacion line,var,oc. %DONE

+ Tests fijando parametros
Utilizar dicts en un servidor cuyo estado son 2 diccionarios (inputs y trazas). % DONE (4 DICTS)
Cuando se calcule una mutacion con traza nueva se enviara un mensaje a si mismo con dicha mutacion y el atomo pending para procesarla. Si llega un mensaje de stop se abortara el procesamiento de los pendings restantes recibidos despues. % DONE (ALGO DIFERENTE)

+ Para integers, cuando proper no genera un test nuevo despues de 50 intentos se incrementa 
el rango de valores validos (al no poner rango explicito proper genera enteros entre -20 y 20 aproximadamente) % DONE
+ Definir la aridad en secer y diferenciar entre funciones con el mismo nombre y distinta aridad %DONE

